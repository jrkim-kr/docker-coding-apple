# 강의 스크립트

docker desktop이 안에서 docker의 모든 기능을 쓸 수 있는게 아니라

터미널에서 명령어 실행해서 이거저거 쓰는 일이 더 많습니다.

그래서 오늘은 컨테이너 다루는 명령어 몇개와 컨테이너 접속, 컨테이너의 실체 이런걸 알아봅시다.

> 이미지 실행 터미널에서 하려면

```
docker run -d 이미지명:태그명
```

터미널에 입력하면 이미지를 컨테이너에서 실행할 수 있다고 했는데

근데 이러면 터미널 하나를 무단 점유하기 때문에 터미널이 또 필요해지면 하나 더 귀찮게 열어야합니다.

그게 싫으면 -d 옵션을 집어넣어서 백그라운드에서 실행가능합니다.

detached의 약자입니다.

> 이미지 실행시 포트 설정

```
docker run -p 8081:8080 -d 이미지명:태그명
```

이미지를 실행할 때 포트를 설정해주고 싶으면 -p 넣고 **내컴퓨터포트:컨테이너포트** 집어넣으면 됩니다.

그래서 위처럼 실행하면 누가 내 컴퓨터 8081 포트로 들어오면 컨테이너의 8080 포트로 안내해주라는 뜻입니다.

포트설정 없이 그냥 띄우면 브라우저로 접속했을 때 아무것도 안뜹니다.

하지만 왜 그런지 이유를 알아야 나중에 응용이 되기 때문에

왜 포트 설정을 해야하는지는 그림을 봅시다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EA%B7%B8%EB%A6%BC12.png)

▲ 포트 설정을 안해놨을 때 왜 localhost:8080으로 접속했을 때 아무것도 없냐면

일단 localhost는 내 컴퓨터로 접속하라는 뜻이고

8080은 8080번 포트로 접속하라는 뜻입니다.

근데 거기로 들어가봤자 웹서버는 없음

왜냐면 웹서버는 **내 컴퓨터 안의 가상컴퓨터에서** 돌아가고 있습니다.

내 컴퓨터 안의 은밀한 곳에서 혼자 돌아가고 있기 때문에

내 컴퓨터 & 가상컴퓨터의 포트끼리 연결하는 작업을 해주면 됩니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EA%B7%B8%EB%A6%BC13.png)

▲ 포트끼리 연결하는건 별거 아니고

"내 컴퓨터 A번 포트로 들어오면 컨테이너의 B번 포트로 보내라" 이건데

이걸 하고 싶으면 컨테이너 실행할 때 **-p 내컴퓨터포트번호:컨테이너포트번호** 하면 됩니다.

똥배관 연결같은 것임

**Q. 다른 컴퓨터 접속은 어떻게 하는 것임?**

그니까 지금 계속 다른 사람들이 내 컴퓨터에 접속한다고 했는데 그건 어떻게 하는것이게요?

실은 웹브라우저 켜서 **어떤컴퓨터IP주소:포트번호** 입력하면 그게 다른 컴퓨터에 접속하는 법입니다.

내가 내 컴퓨터에 접속하는 방법도 있습니다.

**내컴퓨터IP주소:포트번호** 입력하면 되는데

번거롭게 IP주소 찾을 필요 없이 내 컴퓨터는 localhost라고 입력하면 됩니다.

그래서 남의 입장이 되어서 내 컴퓨터로 들어가는걸 시뮬레이션 해보려면

브라우저에 localhost:8080 이런거 입력해보는 것입니다.

> 컨테이너 관련한 명령어들

이미지를 실행중인 컨테이너 관련한 명령어 몇개만 알아봅시다.

```
docker ps
```

현재 실행중인 컨테이너들을 살펴볼 수 있습니다.

```
docker logs
```

컨테이너 컴퓨터 터미널의 로그 출력이 가능합니다.

```bash
docker exec -it 컨테이너이름 sh
```

특정 컨테이너 터미널로 접속이 가능합니다.

그럼 이제 명령어 입력할 때 마다 그 컨테이너 터미널 안에서 실행이 됩니다.

진짠지 궁금하면 들어가서 파일목록 보여주는 ls 명령어 입력해봅시다.

컨테이너를 탈출하려면 ctrl +p 후에 ctrl + q 입력합니다.

```
docker stop 컨테이너이름
```

실행중인 컨테이너 정지해줍니다. 컨테이너 아이디 입력해도 됩니다.

```
docker rm 컨테이너이름
```

정지된 컨테이너를 삭제해줍니다. 정지안된 컨테이너 삭제하려면 -f 옵션을 붙여줍시다.

이런 식으로 쭉 나열해봤는데

뭔가 많이 배운거같은 느낌 주려고 한거고

어짜피 다음날 다 까먹기 때문에 그냥 이런게 있다고만 알고 지나가면 됩니다.

필요할 때 찾아서 쓰십시오.

위 명령어들은 docker desktop 안에서 container 메뉴 들어가면 전부 클릭질로 할 수 있게 되어있습니다.

> 컨테이너 구조

컨테이너의 실체같은게 궁금하면 별거 아닙니다.

리눅스 OS가 제공하는 이거저거 기능을 섞은 것입니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EA%B7%B8%EB%A6%BC14.png)

리눅스의 namespace 기능을 사용하면

프로그램마다 서로 영향을 끼치지 않게 독립적으로 프로세스와 파일구조 같은걸 분리해줄 수 있습니다.

리눅스의 cgroup이라는 기능을 사용하면

프로그램마다 CPU나 램을 얼마나 점유할 건지도 정해둘 수 있습니다.

이런걸 이용하면 혼자 별도로 독립적으로 동작하는 가상 컴퓨터를 만들 수 있는데 그걸 "컨테이너"라고 멋있게 포장해서 부를 뿐입니다.

컨테이너는 여러개 띄울 수 있어서 컴퓨터 한 대에서 여러 컴퓨터를 운영하는 것 처럼 마법을 부릴 수 있고

컨테이너에서 문제가 생겨도 내 컴퓨터로 전염되는 일이 거의 없고

그런 장점이 있습니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EA%B7%B8%EB%A6%BC15.png)

원래 runc같은 프로그램을 쓰면 컨테이너를 띄울 수 있습니다.

실은 containerd라는 프로그램으로 runc를 조작하면 편리해서 그런 경우들도 있습니다.

그럼 Docker는 뭐냐면 containerd, runc를 7살짜리도 쓸 수 있게 만든 프로그램일 뿐입니다.

거기에 이미지 빌드기능, pull 기능, 관리기능 이런걸 더해서 개발자들 편하게 만들어준 것임

그래서 Docker대신 다른 프로그램 사용해도 됩니다.

Podman 이런 것도 유명하고 맥북의 경우 Orbstack 이런게 최근에 가볍다고 유행하던 것 같습니다.

# 핵심 정리

## 📚 학습 목표

이 튜토리얼을 통해 다음을 배울 수 있습니다:

- Docker 컨테이너를 터미널에서 실행하는 방법
- 포트 설정의 원리와 필요성
- 컨테이너 관리 핵심 명령어들
- 컨테이너의 내부 구조와 동작 원리

---

## 1️⃣ Docker 컨테이너 실행하기

### 기본 실행 명령어

```bash
docker run 이미지명:태그명

```

**문제점:** 이 명령어를 실행하면 터미널이 점유되어 다른 작업을 할 수 없습니다.

### 백그라운드 실행 (권장)

```bash
docker run -d 이미지명:태그명

```

- `d` 옵션: **detached**의 약자
  - **detached**: "분리된, 떨어진"이라는 의미
  - 터미널과 컨테이너를 분리하여 실행한다는 뜻
- **백그라운드 실행**: 프로그램이 화면에 보이지 않는 곳에서 조용히 돌아가는 것
  - 마치 컴퓨터를 켜놓고 음악을 들으면서 다른 작업을 하는 것처럼
  - 컨테이너는 뒤에서 계속 돌아가고, 터미널은 다른 명령어를 입력할 수 있음

### 실습 예제

```bash
# nginx 웹서버를 백그라운드에서 실행
docker run -d nginx:latest

```

**nginx란?**

- 전 세계에서 가장 많이 사용되는 웹서버 소프트웨어
- 웹페이지를 보여주는 프로그램 (아파치와 비슷한 역할)
- 가볍고 빠르며 안정적이어서 실습용으로 자주 사용

---

## 2️⃣ 포트 설정의 이해

### 포트 설정 명령어

```bash
docker run -p 8081:8080 -d 이미지명:태그명

```

- **형식:** `p 내컴퓨터포트:컨테이너포트`
- **의미:** 내 컴퓨터의 8081포트로 들어오는 요청을 컨테이너의 8080포트로 전달

### 🤔 왜 포트 설정이 필요할까?

### 포트 설정 없이 실행했을 때

```
브라우저 → localhost:8080 → 내 컴퓨터 8080포트 → ❌ 아무것도 없음

```

**왜 localhost:8080인가?**

- nginx는 기본적으로 80번 포트를 사용
- 하지만 예시에서는 8080을 사용한 이유:
  - 80번 포트는 관리자 권한이 필요한 경우가 많음
  - 8080은 개발할 때 자주 사용하는 대안 포트
  - 실제로는 어떤 포트 번호든 사용 가능

### 포트 설정을 했을 때

```
브라우저 → localhost:8081 → 내 컴퓨터 8081포트 → 컨테이너 8080포트 → ✅ 웹서버 응답

```

### 핵심 개념

- **localhost**: 내 컴퓨터를 의미
- **컨테이너**: 내 컴퓨터 안의 가상 컴퓨터
- **포트 연결**: 내 컴퓨터와 가상 컴퓨터를 연결하는 다리 역할

### 실습 예제

```bash
# nginx를 8081포트로 실행
docker run -p 8081:80 -d nginx:latest

# 브라우저에서 localhost:8081 접속하여 확인

```

---

## 3️⃣ 컨테이너 관리 명령어

### 실행 중인 컨테이너 확인

```bash
docker ps

```

- **ps**: **Process Status**의 약자
  - 리눅스에서 실행 중인 프로세스(프로그램)를 보는 명령어에서 유래
  - Docker에서는 실행 중인 컨테이너들을 의미
- 현재 실행 중인 모든 컨테이너의 정보를 표시
- 컨테이너 **ID (Identifier)**, 이름, 포트 등을 확인할 수 있음

### 컨테이너 로그 확인

```bash
docker logs 컨테이너이름

```

- 컨테이너 내부의 터미널 출력 내용을 확인
- 오류 진단이나 상태 확인에 유용
- **logs**: **log**의 복수형 - 시스템이나 프로그램의 동작 기록

### 컨테이너 내부 접속

```bash
docker exec -it 컨테이너이름 sh

```

- 실행 중인 컨테이너의 터미널에 접속
- **it**: **interactive terminal** 옵션
  - **i**: **interactive**의 약자 - 상호작용할 수 있는 (명령어를 입력하고 결과를 받을 수 있는)
  - **t**: **terminal**의 약자 - 명령어를 입력할 수 있는 화면
- **sh**: **shell**의 약자
  - **shell**: "껍데기"라는 뜻으로, 사용자와 운영체제 사이의 인터페이스
  - 리눅스에서 명령어를 해석하고 실행하는 프로그램
  - **sh (Bourne Shell)**: 1977년 Stephen Bourne이 개발한 가장 기본적인 셸
  - **bash (Bourne Again Shell)**: sh를 개선한 버전, 리눅스 기본 셸
  - **zsh (Z Shell)**: bash보다 더 많은 기능을 가진 현대적 셸, macOS 기본 셸
  - sh → bash → zsh 순으로 발전했지만, sh가 가장 호환성이 좋아서 컨테이너에서 자주 사용
- 컨테이너 내부에서 명령어 실행 가능

### 컨테이너에서 사용할 수 있는 기본 명령어들

- **ls**: **List**의 약자 - 현재 폴더의 파일 목록 보기
- **cat 파일명**: **concatenate**의 약자 - 파일 내용 읽기 (원래는 여러 파일을 연결하는 기능)
- **pwd**: **Print Working Directory**의 약자 - 현재 위치 확인
- **cd 폴더명**: **Change Directory**의 약자 - 폴더 이동

### 컨테이너 탈출 방법

- **방법 1:** `Ctrl + P` 후 `Ctrl + Q` (컨테이너는 계속 실행됨)
- **방법 2:** `exit` 명령어 입력 (컨테이너에서 완전히 나옴)

### 컨테이너 정지

```bash
docker stop 컨테이너이름

```

- 실행 중인 컨테이너를 안전하게 정지
- 컨테이너 ID를 사용해도 됨

### 컨테이너 삭제

```bash
docker rm 컨테이너이름

```

- **rm**: **remove**의 약자 - 정지된 컨테이너를 완전히 삭제
- 실행 중인 컨테이너를 강제 삭제: `docker rm -f 컨테이너이름`
- **f**: **force**의 약자 - 강제로 실행

---

## 4️⃣ 실습 워크플로우

### Step 1: 컨테이너 실행

```bash
docker run -p 8080:80 -d --name my-nginx nginx:latest

```

### Step 2: 컨테이너 확인

```bash
docker ps

```

### Step 3: 브라우저에서 테스트

- `localhost:8080` 접속하여 nginx 페이지 확인

### Step 4: 컨테이너 내부 탐색

```bash
docker exec -it my-nginx sh
ls                              # 파일 목록 보기
cat /etc/nginx/nginx.conf       # nginx 설정 파일 내용 읽기
exit                            # 컨테이너에서 나오기

```

**명령어 설명:**

- **ls**: **List**의 약자 - 현재 폴더에 있는 파일과 폴더 목록을 보여줌
- **cat**: **concatenate**의 약자 - 파일의 내용을 화면에 출력 (원래는 여러 파일을 연결하는 기능)
- **/etc/nginx/nginx.conf**: nginx 웹서버의 설정이 저장된 파일 경로

### Step 5: 로그 확인

```bash
docker logs my-nginx

```

### Step 6: 컨테이너 정리

```bash
docker stop my-nginx
docker rm my-nginx

```

---

## 5️⃣ 컨테이너의 실체와 구조

### 컨테이너란?

컨테이너는 **가상 컴퓨터가 아닙니다!** 리눅스 OS의 기능을 조합한 **프로세스 격리 기술**입니다.

### 핵심 기술들

### 1. Namespace (네임스페이스)

- **역할**: 프로세스와 파일 시스템을 독립적으로 분리
- **효과**: 각 컨테이너가 서로 영향을 주지 않고 실행

### 2. Cgroup (컨트롤 그룹)

- **역할**: CPU, 메모리 사용량 제한
- **효과**: 리소스 사용량을 제어하여 시스템 안정성 확보

### Docker의 위치

```
Docker (사용자 친화적 인터페이스)
    ↓
containerd (컨테이너 관리)
    ↓
runc (실제 컨테이너 실행)
    ↓
Linux Kernel (namespace, cgroup)

```

### Docker의 장점

- **격리성**: 컨테이너 문제가 호스트로 전파되지 않음
- **효율성**: 한 대의 컴퓨터에서 여러 서비스 운영
- **이식성**: 어떤 환경에서든 동일하게 실행
- **확장성**: 필요에 따라 컨테이너 수량 조절

---

## 6️⃣ Docker 대안들

- **Podman**: Docker와 호환되는 데몬리스 컨테이너 엔진
- **Orbstack**: macOS 전용 경량 컨테이너 런타임
- **containerd**: 저수준 컨테이너 런타임

---

## 💡 핵심 요약

1. **백그라운드 실행**: `d` 옵션 사용
2. **포트 연결**: `p 호스트포트:컨테이너포트`
3. **컨테이너 관리**: `ps`, `logs`, `exec`, `stop`, `rm`
4. **컨테이너 본질**: 리눅스 커널 기능을 활용한 프로세스 격리
5. **실용성**: Docker Desktop GUI로도 대부분 작업 가능

### 📝 기억해야 할 명령어

```bash
# 필수 명령어 모음
docker run -p 8080:80 -d nginx        # 실행
docker ps                             # 확인
docker exec -it 컨테이너명 sh          # 접속
docker logs 컨테이너명                 # 로그
docker stop 컨테이너명                 # 정지
docker rm 컨테이너명                   # 삭제
```
