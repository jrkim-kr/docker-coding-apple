# 핵심 정리

## 📚 학습 목표

이 튜토리얼을 통해 다음을 배울 수 있습니다:

- Docker 레이어 캐싱의 원리와 활용법
- Node.js 프로젝트 최적화 기법들
- Spring Boot 애플리케이션 Docker 이미지 구성
- Multi-stage build를 통한 이미지 크기 최소화

---

## 1️⃣ 캐싱을 활용한 빌드 시간 단축

### 기본 원리

Docker는 COPY, RUN 등의 명령어마다 레이어를 생성하고 캐싱합니다.

- 변동사항이 발생한 레이어부터는 캐시를 사용하지 않음
- **핵심**: 자주 변하지 않는 부분을 위쪽에, 자주 변하는 부분을 아래쪽에 배치

### 🚫 잘못된 예시 (Bad Practice)

```docker
FROM node:20-slim
WORKDIR /app

# 모든 파일을 먼저 복사 (소스코드 변경시마다 캐시 무효화)
COPY . .
RUN npm install

EXPOSE 8080
CMD ["node", "server.js"]

```

**문제점:** 소스코드가 조금만 바뀌어도 npm install부터 다시 실행됩니다.

### ✅ 최적화된 예시 (Good Practice)

```docker
FROM node:20-slim
WORKDIR /app

# 1. 의존성 정보만 먼저 복사
COPY package*.json ./

# 2. 의존성 설치 (package.json이 변하지 않으면 캐시 활용)
RUN npm install

# 3. 소스코드는 나중에 복사 (소스 변경시에도 위 레이어들은 캐시 활용)
COPY . .

EXPOSE 8080
CMD ["node", "server.js"]

```

### 실습하기

```bash
# 빌드 시간 측정
time docker build -t test-app .

# 소스코드 수정 후 다시 빌드하여 시간 비교

```

---

## 2️⃣ Node.js 프로젝트 최적화

### npm ci 사용하기

```docker
# 🚫 비추천: 버전이 유동적일 수 있음
RUN npm install

# ✅ 추천: package-lock.json을 기반으로 정확한 버전 설치
RUN npm ci --only=production

```

**npm ci란?**

- **ci**: **Continuous Integration**의 약자
- package-lock.json 파일을 기반으로 정확한 버전 설치
- package.json의 "^4.21" 같은 범위 표기를 무시하고 lock 파일의 정확한 버전 사용

### 환경변수 설정

```docker
# 프로덕션 환경 설정으로 성능 향상
ENV NODE_ENV=production

```

**NODE_ENV=production 효과:**

- Express 같은 라이브러리에서 로그 출력량 감소
- 개발용 기능 비활성화로 성능 향상
- 에러 메시지 간소화로 보안 향상

### 보안을 위한 권한 낮추기

```docker
# root 대신 일반 사용자로 실행
USER node
CMD ["node", "server.js"]

```

**보안 원칙:**

- 컨테이너 내부 프로세스는 최소 권한으로 실행
- node 이미지에는 이미 'node' 사용자가 생성되어 있음
- 만약 공격받아도 피해 범위를 최소화

### 완성된 최적화 Dockerfile

```docker
# Node.js 버전 22의 slim 이미지를 기본 이미지로 사용
# slim 버전은 불필요한 패키지들이 제거된 경량화된 이미지
FROM node:22-slim

# 컨테이너 내부의 작업 디렉토리를 /app으로 설정
# 이후 모든 명령어는 이 디렉토리에서 실행됨
WORKDIR /app

# package.json과 package-lock.json 파일을 컨테이너로 복사
# 와일드카드(*)를 사용하여 두 파일 모두 복사 (package-lock.json이 없어도 에러 없음)
# 점(.)은 현재 작업 디렉토리(/app)를 의미
COPY package*.json .

# npm ci 명령을 실행하여 package-lock.json 기반으로 정확한 버전의 의존성 설치
# JSON 배열 형태로 작성하여 셸을 거치지 않고 직접 실행 (exec form)
# ci는 Continuous Integration의 약자로 빌드 환경에 최적화됨
RUN ["npm", "ci"]

# 환경변수를 production으로 설정
# Express 등의 라이브러리가 프로덕션 모드로 동작하여 성능 향상
ENV NODE_ENV=production

# 현재 디렉토리의 모든 파일과 폴더를 컨테이너의 /app 디렉토리로 복사
# 소스코드는 package.json보다 자주 변경되므로 나중에 복사하여 캐시 활용
COPY . .

# 컨테이너가 8080 포트를 사용한다고 문서화
# 실제로 포트를 열지는 않고, 단순히 메타데이터로 기록
EXPOSE 8080

# 실행 사용자를 node로 변경 (보안을 위해 root 권한 대신 일반 사용자 권한 사용)
# node 이미지에는 이미 'node' 사용자가 생성되어 있음
USER node

# 컨테이너가 시작될 때 실행할 기본 명령어를 설정
# node server.js 명령으로 서버 애플리케이션을 실행
CMD ["node", "server.js"]

```

### 🔍 각 명령어 상세 분석

### FROM node:22-slim

- **node:22**: Node.js 버전 22 사용
- **slim**: 최소한의 패키지만 포함된 경량 버전
- **대안**: `alpine` (더 작음), `bullseye` (전체 버전)

### WORKDIR /app

- 컨테이너 내 작업 디렉토리 설정
- 이후 모든 명령어는 `/app`에서 실행
- 디렉토리가 없으면 자동으로 생성

### COPY package\*.json .

- _package.json_: `package.json`과 `package-lock.json` 모두 복사
- **점(.)**: 현재 WORKDIR(`/app`)을 의미
- **캐싱 전략**: 의존성 정보만 먼저 복사하여 캐시 활용

### RUN ["npm", "ci"]

- **npm ci**: package-lock.json 기반 정확한 버전 설치
- **JSON 배열**: exec form 사용으로 셸 없이 직접 실행
- **npm install과 차이**: 더 빠르고 결정적(deterministic)

### ENV NODE_ENV=production

- **환경변수 설정**: 컨테이너 실행시 적용
- **production 모드**: 로깅 감소, 성능 최적화
- **런타임에서 변경 가능**: `docker run -e NODE_ENV=development`

### COPY . .

- **모든 파일 복사**: 소스코드, 설정 파일 등
- **의존성 설치 후**: 캐시 최적화를 위한 순서
- **.dockerignore**: 불필요한 파일 제외 가능

### EXPOSE 8080

- **메타데이터**: 문서화 목적
- **실제 포트 바인딩**: `docker run -p 8080:8080`으로 별도 설정
- **관례적 포트**: 8080은 개발용 웹서버 포트

### USER node

- **보안 강화**: root 권한 대신 일반 사용자
- **node 사용자**: 이미 생성되어 있는 시스템 사용자
- **권한 제한**: 컨테이너 탈옥시 피해 최소화

### 📋 Dockerfile 작성 베스트 프랙티스

### 1. 레이어 순서 최적화

```docker
# ✅ 좋은 순서: 변경 빈도 순
FROM node:22-slim        # 1. 베이스 이미지 (거의 변경 안됨)
WORKDIR /app            # 2. 작업 디렉토리 설정
COPY package*.json .    # 3. 의존성 정보 (가끔 변경)
RUN ["npm", "ci"]       # 4. 의존성 설치
ENV NODE_ENV=production # 5. 환경변수 설정
COPY . .               # 6. 소스코드 (자주 변경)
EXPOSE 8080            # 7. 포트 설정
USER node              # 8. 사용자 변경
CMD ["node", "server.js"] # 9. 실행 명령

```

### 2. 명령어 형태 비교

**Shell Form vs Exec Form**

```docker
# 🚫 Shell Form (권장하지 않음)
RUN npm ci
CMD node server.js

# ✅ Exec Form (권장)
RUN ["npm", "ci"]
CMD ["node", "server.js"]

```

**차이점:**

- **Shell Form**: `/bin/sh -c` 를 통해 실행
- **Exec Form**: 직접 실행, PID 1로 실행되어 시그널 처리 가능

### 3. .dockerignore 활용

```
# Node.js 관련
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# 개발 도구
.git
.gitignore
README.md
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE 설정
.vscode
.idea
*.swp
*.swo

# OS 관련
.DS_Store
Thumbs.db

# 테스트 및 커버리지
coverage/
.nyc_output
test/
*.test.js

```

### 4. 보안 고려사항

```docker
# ✅ 보안 강화 팁
FROM node:22-slim        # slim/alpine 이미지 사용

# 보안 업데이트 적용
RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# 불필요한 파일 정리
RUN ["npm", "ci", "--only=production"] && \
    npm cache clean --force

# 일반 사용자로 실행
USER node

# 읽기 전용 루트 파일시스템 (런타임 옵션)
# docker run --read-only --tmpfs /tmp app

```

### 5. 멀티스테이지 빌드 활용

```docker
# 개발 의존성 포함한 빌드 스테이지
FROM node:22-slim AS builder
WORKDIR /app
COPY package*.json .
RUN ["npm", "ci"]
COPY . .
RUN ["npm", "run", "build"]

# 프로덕션 런타임 스테이지
FROM node:22-slim AS production
WORKDIR /app
ENV NODE_ENV=production

# 프로덕션 의존성만 설치
COPY package*.json .
RUN ["npm", "ci", "--only=production"]

# 빌드된 결과물만 복사
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/public ./public

USER node
EXPOSE 8080
CMD ["node", "dist/server.js"]

```

---

## 3️⃣ Spring Boot 프로젝트 최적화

### 기본 방법

```docker
FROM amazoncorretto:21.0.4
WORKDIR /app
COPY . .
RUN ./gradlew build
CMD ["java", "-jar", "build/libs/app.jar"]

```

**문제점:** 최종 이미지에 불필요한 소스코드와 빌드 도구들이 포함됨

### 🚀 Multi-stage Build로 최적화

```docker
# 빌드 스테이지
FROM amazoncorretto:21.0.4 AS build
WORKDIR /app
COPY . .
RUN ./gradlew build

# 런타임 스테이지
FROM amazoncorretto:21.0.4 AS runtime
WORKDIR /app

# 빌드된 JAR 파일만 복사
COPY --from=build /app/build/libs/*.jar /app/server.jar

# JAR 파일 실행
CMD ["java", "-jar", "/app/server.jar"]

```

**장점:**

- 최종 이미지에는 JAR 파일, JDK, OS만 포함
- 소스코드, Gradle, 빌드 캐시 등 불필요한 파일 제거
- 이미지 크기 대폭 감소

### 💡 더 간단한 방법: Gradle Plugin 활용

```bash
# Spring Boot에 내장된 이미지 빌드 명령
./gradlew bootBuildImage

```

**bootBuildImage 특징:**

- Cloud Native Buildpacks 기술 사용
- 최적화된 레이어 구조 자동 생성
- JVM 메모리 설정 자동 최적화

---

## 4️⃣ Multi-stage Build 마스터하기

### 핵심 개념

- `FROM`을 여러 번 사용하여 단계별 빌드
- 각 스테이지는 독립적이지만 `-from` 옵션으로 파일 복사 가능
- 최종 이미지에는 마지막 FROM의 내용만 포함

### Next.js 프로젝트 예시

```docker
# 의존성 설치 스테이지
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# 빌드 스테이지
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 런타임 스테이지
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production

# 필요한 파일만 복사
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package.json ./package.json

EXPOSE 3000
CMD ["npm", "start"]

```

### 🔍 스테이지별 역할

1. **deps**: 프로덕션 의존성만 설치
2. **builder**: 전체 의존성 설치 + 빌드 실행
3. **runner**: 실행에 필요한 파일만 조합

---

# 강의 스크립트

나만의 이미지를 만들고 싶으면 Dockerfile에다가 레시피를 작성하면 됩니다.

하지만 docker build 시간 단축, 용량절약, 보안향상을 위한 매직 레시피 같은게 있습니다.

> 좋은 관습 1. 캐싱

프로젝트가 커지면 docker build 입력해서 기다리는 시간도 끔찍해지는 경우가 있습니다.

그러면 배포할 때마다 docker build 입력해야할텐데 그 때마다 속터져 죽습니다.

죽기 싫으면 좋은 방법이 하나 있는데 그게 뭐냐면

Dockerfile 작성시 **"빌드할 때마다 변동사항이 많이 생기는 부분들을 최대한 아래 쪽에 적기"**입니다.

그럼 build 시간이 단축될 수 있습니다.

**Q. 밑에 적는걸로 뭐가 빨라짐?**

원래 빌드작업할 때 COPY, RUN 명령을 실행할 때 마다 도커가 몰래 캐싱을 해놓습니다.

캐싱은 결과를 몰래 저장해놓고 나중에 필요해지면 재사용한다는 소리입니다.

- 캐싱된 명령어들은 매우 빠르게 처리해줄 수 있습니다.
- 변동사항이 생긴 명령어부터는 캐싱된걸 사용하지 않습니다.
- 그럼 변동사항이 많은건 좀 아래쪽으로 내리면 좋겠군요.

예를 들면 Node.js로 웹서버 개발하는 경우는

package.json 내용이나 npm install로 라이브러리 설치하는건 날마다 변동사항이 거의 없습니다.

(라이브러리를 매일매일 설치하진 않지 않습니까)

그래서

1. OS와 Node.js 설치하고

2. package.json 먼저 옮겨서 라이브러리 설치부터 먼저 하고

3. 그 다음에 자주 변동되는 소스코드 옮기고

...

그런 식으로 Dockerfile을 작성하면 매번 docker build 할 때 약간이라도 더 빨라질 수 있는 것입니다.

```sql
(Dockerfile)

FROM node:20-slim
WORKDIR /app
COPY package*.json .
RUN ["npm", "install"]

COPY . .
EXPOSE 8080
CMD ["node", "server.js"]
```

그래서 이렇게 고쳐봤습니다.

이제 빌드할 때 마다 뭔가 빨라진 느낌이 들 수 있는데 지금은 별차이 없을듯요

> 좋은 관습 2. npm ci

Dockerfile 작성시 좋은 관습을 몇개 알아봅시다.

Node.js 개발할 때 라이브러리 정확한 버전 설치하려면 npm install 말고 npm ci 라는 커맨드를 쓰는 것도 좋습니다.

그냥 npm install하면 package.json에 기록된게 설치되긴 하는데

"express" : "^4.21" 가끔 이런 식으로 표기되어있으면 **맨 앞자리가 4만 되면 된다는 뜻**이라서

나중에 라이브러리가 업데이트되면 실수로 4.22 버전이 막 설치되고 그럴 수 있습니다.

그래서 이거 ^ 표시를 지우거나 아니면 package-lock.json에 내가 쓰는 라이브러리의 정확한 버전이 써있기 때문에

그걸 바탕으로 설치하라고 입력하는게 npm ci 입니다.

심심하면 Dockerfile을 그렇게 수정해봅시다.

> 좋은 관습 3. ENV

```objectivec
(Dockerfile)

ENV NODE_ENV=production
CMD 어쩌구~
```

ENV 라는 명령어를 쓰면 환경변수를 집어넣어서 이미지를 빌드할 수 있습니다.

**ENV 환경변수이름=값** 사용하면 됩니다.

이런걸 왜 쓰냐면 옛날부터 존재하던 express 같은 라이브러리들은

NODE_ENV=production을 집어넣어놔야 로그출력양을 좀 줄이고 그래서 성능이 향상되고 그런 케이스가 있습니다.

그래서 Node.js 개발시 설정해두면 나쁠건 없습니다.

참고로 docker run할 때도 -e 옵션으로 환경변수를 그때그때 집어넣어서 이미지를 실행할 수 있습니다.

> 좋은 관습 4. 권한 낮추기

보안적으로 더 나은 습관도 있는데

원래 Dockerfile에 적은 명령어들은 전부 root 권한으로 실행됩니다.

마지막에 서버 띄우는 명령어는 root 말고 **권한을 좀 낮춰서 실행하는게** 약간 더 안전하고 좋습니다.

그럴려면 유저를 하나 생성하고 그걸로 유저를 바꿔서 실행하라고 코드짜면 되는데

근데 node 공식 이미지의 경우엔 node라는 이름의 유저가 이미 만들어져있습니다.

그래서 그거 써도 되겠습니다.

```objectivec
(Dockerfile)

USER node
CMD 어쩌구~
```

**USER 유저이름** 적으면 그 유저로 변경됩니다.

유저가 제공되지 않는 이미지는 직접 유저만드는 명령어 찾아서 씁시다.

참고로 실은 지금 하는 것들은 친절한 node 공식 이미지 설명서에 다 나와있는 것들이라

이런건 어디서 배워야 알 수 있는 건 아니고 찾아보면 나옵니다.

https://github.com/nodejs/docker-node/blob/main/docs/BestPractices.md

> Spring boot 프로젝트의 경우

Spring boot로 만든 웹서버가 있으면 그건 어떻게 이미지로 만드는지 알아봅시다.

Spring boot 모르면 그냥 취미로 들어봅시다.

Spring boot 서버를 실행하려면

1. 터미널에서 **./gradlew build** 입력해서 .jar파일을 만들고

2. 터미널에서 **java -jar .jar파일경로** 입력해서 .jar 파일 실행하면 끝입니다.

매우 간단한 편이라 Dockerfile도 저렇게 작성하면 이미지 생성 끝입니다.

```sql
FROM amazoncorretto:21.0.4
WORKDIR /app
COPY . .
RUN ./gradlew build
CMD ["java", "-jar", ".jar파일경로"]
```

프로젝트 폴더에 Dockerfile 만들고 이런거 작성하는게 끝입니다.

- Java 21버전으로 설치했는데 여러분이 쓰던 버전으로 설치하면 되겠습니다.
- 아마 .jar 파일은 /build/libs 폴더에 생성되어있을 것입니다.

근데 용량을 더 줄이고 싶으면 이런 편법을 써도 되는데

실은 생성된 .jar 파일만 있으면 서버를 돌릴 수 있기 때문에 다른 소스코드나 그런건 전혀 필요없습니다.

그래서 **.jar 파일 하나만 담은 이미지를 생성해서 그것만 실행**하라고 Dockerfile을 작성하면

이미지 용량을 훨씬 작게 만들 수 있습니다.

1. 터미널에 ./gradlew build를 입력해서 .jar파일을 만들기

2. 새로운 이미지를 만들어서 그 .jar 파일을 새로운 이미지로 옮기기

3. 명령어로 .jar 파일을 실행하기

이렇게 작성하면 되는 것임

> multi-stage build

```sql
FROM amazoncorretto:21.0.4 AS build
WORKDIR /app
COPY . .
RUN ./gradlew build

# Runtime stage
FROM amazoncorretto:21.0.4 AS runtime
WORKDIR /app
COPY--from=build /app/build/libs/*.jar /app/server.jar
CMD ["java", "-jar", "/app/server.jar"]
```

실은 Dockerfile에 FROM을 2번 이상 작성할 수 있는데

FROM을 만날 때 마다 위에 있는 작업내역들이 삭제되고 새로운 마음으로 깨끗하게 시작됩니다.

근데 깨끗하게 시작할 때 **위의 작업내역에서 만든 파일들을 몰래 훔쳐올 수 있습니다.**

이게 비결임

첫째 FROM에선 /app 폴더에서 .jar 파일만 만들어줍니다.

두번째 FROM에선 이전 FROM에서 나온 .jar 파일을 /app/server.jar 경로로 훔쳐오라고 했습니다.

- -from=build 이러면 build라고 이름지은 곳에 있던 파일을 카피하라는 뜻입니다.

(AS 명령어 쓰면 FROM마다 이름을 마음대로 붙일 수 있습니다.)

그 다음에 마지막에 .jar 파일을 실행하는겁니다.

그럼 이제 최종 이미지에는 .jar 파일, 리눅스OS, 자바21 JDK 이 정도만 들어있어서 좀 가벼워졌겠군요.

FROM 여러번 쓰는 짓거리를 multi-stage build 라고 하는데

그래서 빌드과정이 필요한 프로젝트들은 이런 식으로 작성해서 용량을 줄이고 보안도 약간 챙길 수 있습니다.

> bootBuildImage 명령

실은 Spring boot에서 gradle을 쓰는 경우에는 이미지 만드는 명령어가 아마 내장되어있습니다.

터미널에 ./gradlew bootBuildImage 입력하면 이미지를 자동으로 만들어주기 때문에

Dockerfile 작성귀찮으면 한 번 사용해봅시다.

> Next.js 프로젝트는

Next.js 프로젝트도 코드를 다 짰으면 npm run build 명령어 입력하고 npm start 이런 걸로 코드를 실행해야합니다.

그래서 빌드 과정이 필요하기 때문에

이것도 Dockerfile 작성할 때 multi-stage build 잡기술을 이용하면 용량을 더 줄일 수 있습니다.

근데 그것보다 더 간편한게 있는데 nextjs output standalone 같은거 검색해봅시다.

그러면 배포할 때 꼭 필요한 파일만 알아서 남겨줍니다.

오늘의 결론은

Dockerfile 작성할 때 잡기술 넣으면 여러 장점이 있습니다.

그리고 성능이나 최적화에 집착하면 고수처럼 보일 수 있습니다.
