# 핵심 정리

## 📚 학습 목표

이 튜토리얼을 통해 다음을 배울 수 있습니다:

- Docker 레이어 캐싱의 원리와 활용법
- Node.js 프로젝트 최적화 기법들
- Spring Boot 애플리케이션 Docker 이미지 구성
- Multi-stage build를 통한 이미지 크기 최소화

---

## 1️⃣ 캐싱을 활용한 빌드 시간 단축

### 기본 원리

Docker는 COPY, RUN 등의 명령어마다 레이어를 생성하고 캐싱합니다.

- 변동사항이 발생한 레이어부터는 캐시를 사용하지 않음
- **핵심**: 자주 변하지 않는 부분을 위쪽에, 자주 변하는 부분을 아래쪽에 배치

### 🚫 잘못된 예시 (Bad Practice)

```docker
FROM node:20-slim
WORKDIR /app

# 모든 파일을 먼저 복사 (소스코드 변경시마다 캐시 무효화)
COPY . .
RUN npm install

EXPOSE 8080
CMD ["node", "server.js"]

```

**문제점:** 소스코드가 조금만 바뀌어도 npm install부터 다시 실행됩니다.

### ✅ 최적화된 예시 (Good Practice)

```docker
FROM node:20-slim
WORKDIR /app

# 1. 의존성 정보만 먼저 복사
COPY package*.json ./

# 2. 의존성 설치 (package.json이 변하지 않으면 캐시 활용)
RUN npm install

# 3. 소스코드는 나중에 복사 (소스 변경시에도 위 레이어들은 캐시 활용)
COPY . .

EXPOSE 8080
CMD ["node", "server.js"]

```

### 실습하기

```bash
# 빌드 시간 측정
time docker build -t test-app .

# 소스코드 수정 후 다시 빌드하여 시간 비교

```

---

## 2️⃣ Node.js 프로젝트 최적화

### npm ci 사용하기

```docker
# 🚫 비추천: 버전이 유동적일 수 있음
RUN npm install

# ✅ 추천: package-lock.json을 기반으로 정확한 버전 설치
RUN npm ci --only=production

```

**npm ci란?**

- **ci**: **Continuous Integration**의 약자
- package-lock.json 파일을 기반으로 정확한 버전 설치
- package.json의 "^4.21" 같은 범위 표기를 무시하고 lock 파일의 정확한 버전 사용

### 환경변수 설정

```docker
# 프로덕션 환경 설정으로 성능 향상
ENV NODE_ENV=production

```

**NODE_ENV=production 효과:**

- Express 같은 라이브러리에서 로그 출력량 감소
- 개발용 기능 비활성화로 성능 향상
- 에러 메시지 간소화로 보안 향상

### 보안을 위한 권한 낮추기

```docker
# root 대신 일반 사용자로 실행
USER node
CMD ["node", "server.js"]

```

**보안 원칙:**

- 컨테이너 내부 프로세스는 최소 권한으로 실행
- node 이미지에는 이미 'node' 사용자가 생성되어 있음
- 만약 공격받아도 피해 범위를 최소화

### 완성된 최적화 Dockerfile

```docker
# Node.js 버전 22의 slim 이미지를 기본 이미지로 사용
# slim 버전은 불필요한 패키지들이 제거된 경량화된 이미지
FROM node:22-slim

# 컨테이너 내부의 작업 디렉토리를 /app으로 설정
# 이후 모든 명령어는 이 디렉토리에서 실행됨
WORKDIR /app

# package.json과 package-lock.json 파일을 컨테이너로 복사
# 와일드카드(*)를 사용하여 두 파일 모두 복사 (package-lock.json이 없어도 에러 없음)
# 점(.)은 현재 작업 디렉토리(/app)를 의미
COPY package*.json .

# npm ci 명령을 실행하여 package-lock.json 기반으로 정확한 버전의 의존성 설치
# JSON 배열 형태로 작성하여 셸을 거치지 않고 직접 실행 (exec form)
# ci는 Continuous Integration의 약자로 빌드 환경에 최적화됨
RUN ["npm", "ci"]

# 환경변수를 production으로 설정
# Express 등의 라이브러리가 프로덕션 모드로 동작하여 성능 향상
ENV NODE_ENV=production

# 현재 디렉토리의 모든 파일과 폴더를 컨테이너의 /app 디렉토리로 복사
# 소스코드는 package.json보다 자주 변경되므로 나중에 복사하여 캐시 활용
COPY . .

# 컨테이너가 8080 포트를 사용한다고 문서화
# 실제로 포트를 열지는 않고, 단순히 메타데이터로 기록
EXPOSE 8080

# 실행 사용자를 node로 변경 (보안을 위해 root 권한 대신 일반 사용자 권한 사용)
# node 이미지에는 이미 'node' 사용자가 생성되어 있음
USER node

# 컨테이너가 시작될 때 실행할 기본 명령어를 설정
# node server.js 명령으로 서버 애플리케이션을 실행
CMD ["node", "server.js"]

```

### 🔍 각 명령어 상세 분석

### FROM node:22-slim

- **node:22**: Node.js 버전 22 사용
- **slim**: 최소한의 패키지만 포함된 경량 버전
- **대안**: `alpine` (더 작음), `bullseye` (전체 버전)

### WORKDIR /app

- 컨테이너 내 작업 디렉토리 설정
- 이후 모든 명령어는 `/app`에서 실행
- 디렉토리가 없으면 자동으로 생성

### COPY package\*.json .

- _package.json_: `package.json`과 `package-lock.json` 모두 복사
- **점(.)**: 현재 WORKDIR(`/app`)을 의미
- **캐싱 전략**: 의존성 정보만 먼저 복사하여 캐시 활용

### RUN ["npm", "ci"]

- **npm ci**: package-lock.json 기반 정확한 버전 설치
- **JSON 배열**: exec form 사용으로 셸 없이 직접 실행
- **npm install과 차이**: 더 빠르고 결정적(deterministic)

### ENV NODE_ENV=production

- **환경변수 설정**: 컨테이너 실행시 적용
- **production 모드**: 로깅 감소, 성능 최적화
- **런타임에서 변경 가능**: `docker run -e NODE_ENV=development`

### COPY . .

- **모든 파일 복사**: 소스코드, 설정 파일 등
- **의존성 설치 후**: 캐시 최적화를 위한 순서
- **.dockerignore**: 불필요한 파일 제외 가능

### EXPOSE 8080

- **메타데이터**: 문서화 목적
- **실제 포트 바인딩**: `docker run -p 8080:8080`으로 별도 설정
- **관례적 포트**: 8080은 개발용 웹서버 포트

### USER node

- **보안 강화**: root 권한 대신 일반 사용자
- **node 사용자**: 이미 생성되어 있는 시스템 사용자
- **권한 제한**: 컨테이너 탈옥시 피해 최소화

### 📋 Dockerfile 작성 베스트 프랙티스

### 1. 레이어 순서 최적화

```docker
# ✅ 좋은 순서: 변경 빈도 순
FROM node:22-slim        # 1. 베이스 이미지 (거의 변경 안됨)
WORKDIR /app            # 2. 작업 디렉토리 설정
COPY package*.json .    # 3. 의존성 정보 (가끔 변경)
RUN ["npm", "ci"]       # 4. 의존성 설치
ENV NODE_ENV=production # 5. 환경변수 설정
COPY . .               # 6. 소스코드 (자주 변경)
EXPOSE 8080            # 7. 포트 설정
USER node              # 8. 사용자 변경
CMD ["node", "server.js"] # 9. 실행 명령

```

### 2. 명령어 형태 비교

**Shell Form vs Exec Form**

```docker
# 🚫 Shell Form (권장하지 않음)
RUN npm ci
CMD node server.js

# ✅ Exec Form (권장)
RUN ["npm", "ci"]
CMD ["node", "server.js"]

```

**차이점:**

- **Shell Form**: `/bin/sh -c` 를 통해 실행
- **Exec Form**: 직접 실행, PID 1로 실행되어 시그널 처리 가능

### 3. .dockerignore 활용

```
# Node.js 관련
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# 개발 도구
.git
.gitignore
README.md
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE 설정
.vscode
.idea
*.swp
*.swo

# OS 관련
.DS_Store
Thumbs.db

# 테스트 및 커버리지
coverage/
.nyc_output
test/
*.test.js

```

### 4. 보안 고려사항

```docker
# ✅ 보안 강화 팁
FROM node:22-slim        # slim/alpine 이미지 사용

# 보안 업데이트 적용
RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# 불필요한 파일 정리
RUN ["npm", "ci", "--only=production"] && \
    npm cache clean --force

# 일반 사용자로 실행
USER node

# 읽기 전용 루트 파일시스템 (런타임 옵션)
# docker run --read-only --tmpfs /tmp app

```

### 5. 멀티스테이지 빌드 활용

```docker
# 개발 의존성 포함한 빌드 스테이지
FROM node:22-slim AS builder
WORKDIR /app
COPY package*.json .
RUN ["npm", "ci"]
COPY . .
RUN ["npm", "run", "build"]

# 프로덕션 런타임 스테이지
FROM node:22-slim AS production
WORKDIR /app
ENV NODE_ENV=production

# 프로덕션 의존성만 설치
COPY package*.json .
RUN ["npm", "ci", "--only=production"]

# 빌드된 결과물만 복사
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/public ./public

USER node
EXPOSE 8080
CMD ["node", "dist/server.js"]

```

---

## 3️⃣ Spring Boot 프로젝트 최적화

### 기본 방법

```docker
FROM amazoncorretto:21.0.4
WORKDIR /app
COPY . .
RUN ./gradlew build
CMD ["java", "-jar", "build/libs/app.jar"]

```

**문제점:** 최종 이미지에 불필요한 소스코드와 빌드 도구들이 포함됨

### 🚀 Multi-stage Build로 최적화

```docker
# 빌드 스테이지
FROM amazoncorretto:21.0.4 AS build
WORKDIR /app
COPY . .
RUN ./gradlew build

# 런타임 스테이지
FROM amazoncorretto:21.0.4 AS runtime
WORKDIR /app

# 빌드된 JAR 파일만 복사
COPY --from=build /app/build/libs/*.jar /app/server.jar

# JAR 파일 실행
CMD ["java", "-jar", "/app/server.jar"]

```

**장점:**

- 최종 이미지에는 JAR 파일, JDK, OS만 포함
- 소스코드, Gradle, 빌드 캐시 등 불필요한 파일 제거
- 이미지 크기 대폭 감소

### 💡 더 간단한 방법: Gradle Plugin 활용

```bash
# Spring Boot에 내장된 이미지 빌드 명령
./gradlew bootBuildImage

```

**bootBuildImage 특징:**

- Cloud Native Buildpacks 기술 사용
- 최적화된 레이어 구조 자동 생성
- JVM 메모리 설정 자동 최적화

---

## 4️⃣ Multi-stage Build 마스터하기

### 핵심 개념

- `FROM`을 여러 번 사용하여 단계별 빌드
- 각 스테이지는 독립적이지만 `-from` 옵션으로 파일 복사 가능
- 최종 이미지에는 마지막 FROM의 내용만 포함

### Next.js 프로젝트 예시

```docker
# 의존성 설치 스테이지
FROM node:20-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# 빌드 스테이지
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 런타임 스테이지
FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production

# 필요한 파일만 복사
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package.json ./package.json

EXPOSE 3000
CMD ["npm", "start"]

```

### 🔍 스테이지별 역할

1. **deps**: 프로덕션 의존성만 설치
2. **builder**: 전체 의존성 설치 + 빌드 실행
3. **runner**: 실행에 필요한 파일만 조합

---
