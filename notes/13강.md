# 13. Docker compose 3. 실시간 개발, graceful shutdown

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Compose의 Watch 기능을 활용한 실시간 개발 환경 구축
- 컨테이너의 Graceful Shutdown 구현
- 자동 빌드 설정으로 개발 워크플로우 개선
- 프로덕션과 동일한 환경에서 편리하게 개발하기

---

## 📚 사전 지식

- Docker Compose 기본 사용법
- Node.js 또는 기타 웹 프레임워크 기초
- Signal과 Process에 대한 기본 이해
- Dockerfile 작성 경험

---

## 1단계: 문제 상황 이해하기

### 컨테이너로 개발할 때의 불편함

컨테이너로 개발하는 이유는 여러 가지입니다:

- ✅ 팀원끼리 개발환경을 아예 똑같이 맞출 수 있음
- ✅ 배포 전에 프로덕션과 유사한 환경에서 테스트 가능
- ✅ 로컬 환경을 오염시키지 않음

하지만 **코드 변경사항을 확인하기 위한 과정이 너무 복잡**합니다.

### 기존 워크플로우의 문제점

코드를 수정했을 때:

```
1. docker compose down     ← 컨테이너 중지
2. docker build            ← 이미지 다시 빌드
3. docker compose up       ← 컨테이너 다시 시작

```

**"안녕" → "안녕123"** 이런 작은 변경도 매번 이 과정을 반복해야 합니다!

---

## 2단계: 자동 빌드 설정

### docker-compose.yml에 build 옵션 추가

가장 간단한 개선 방법은 자동 빌드 설정입니다.

```yaml
services:
  webserver:
    image: nodeserver:1
    build: . # Dockerfile 경로 지정
    ports:
      - 8080:8080
```

**`build: .`** 옵션을 추가하면:

- 해당 경로의 Dockerfile을 자동으로 찾음
- `docker compose up` 시 자동으로 이미지 빌드

### -build 플래그 사용하기

```bash
# 기존 명령어
docker compose up

# 자동 빌드 포함
docker compose up --build

```

이제 워크플로우가 다음처럼 단순해집니다:

```
1. docker compose down
2. docker compose up --build   ← 빌드 + 실행을 한 번에!

```

**명령어 하나가 줄어들었습니다!** 🎉

---

## 3단계: Graceful Shutdown 구현

### 왜 컨테이너 종료가 느릴까?

컨테이너를 끄는데 **10초 이상** 걸린다면?
→ **서버를 제대로 종료하는 코드가 없기 때문**입니다.

### Docker의 종료 프로세스

```
[Docker Engine]
    ↓
"좋은 말 할 때 알아서 꺼라" (SIGTERM 신호 전송)
    ↓
[Container/Program]
    ↓
종료 코드 없음? → 10초 대기 → 강제 종료 (SIGKILL)

```

### Signal 처리 코드 작성

**Node.js + Express 예제:**

```jsx
// server.js
const express = require("express");
const app = express();

// ... 라우트 설정 등 ...

const server = app.listen(8080, () => {
  console.log("Server running on port 8080");
});

// SIGTERM 신호 처리 (Docker가 보내는 종료 신호)
process.on("SIGTERM", () => {
  console.log("SIGTERM received. Shutting down gracefully...");
  server.close(() => {
    console.log("HTTP server closed");
    // 필요한 경우 DB 연결 해제 등 추가
    process.exit(0);
  });
});

// SIGINT 신호 처리 (Ctrl+C)
process.on("SIGINT", () => {
  console.log("SIGINT received. Shutting down gracefully...");
  server.close(() => {
    console.log("HTTP server closed");
    process.exit(0);
  });
});
```

### 각 부분 설명

- **`SIGTERM`**: Docker가 컨테이너를 중지할 때 보내는 신호
- **`SIGINT`**: 터미널에서 `Ctrl+C`를 눌렀을 때 보내는 신호
- **`server.close()`**: 현재 처리 중인 요청을 완료한 후 서버 종료
- **`process.exit(0)`**: 프로세스를 정상적으로 종료

### DB 사용 시 추가 처리

```jsx
process.on("SIGTERM", () => {
  server.close(async () => {
    console.log("HTTP server closed");

    // DB 연결 해제
    await db.disconnect();
    console.log("Database connection closed");

    process.exit(0);
  });
});
```

---

## 4단계: Watch 기능 설정 (핵심!)

### Watch 기능이란?

Docker Compose의 **Watch 기능**은:

- 파일 변경을 감지하면 **자동으로 컨테이너에 반영**
- 빌드 없이 즉시 변경사항 확인 가능
- 개발 속도를 획기적으로 향상

### 기본 Sync 설정

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - node_modules/
```

**각 옵션 설명:**

| 옵션           | 설명                         |
| -------------- | ---------------------------- |
| `action: sync` | 파일 변경 시 컨테이너로 복사 |
| `path: .`      | 감시할 로컬 경로 (현재 폴더) |
| `target: /app` | 컨테이너 내부의 대상 경로    |
| `ignore`       | 제외할 파일/폴더 목록        |

### Watch 실행하기

```bash
docker compose up --watch

```

이제 코드를 수정하고 저장하면:

1. Watch가 변경 감지
2. 자동으로 컨테이너에 복사
3. **빌드 없이 즉시 반영!**

### 주의사항

파일은 복사되지만, **서버는 자동으로 재시작되지 않습니다!**

브라우저에서 확인해도 변경사항이 반영되지 않는 이유:

- 로컬 개발도 코드 수정 후 서버 재시작 필요
- 컨테이너도 마찬가지!

### Sync + Restart 설정

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        - action: sync+restart
          path: .
          target: /app
          ignore:
            - node_modules/
```

- **`sync+restart`**를 사용하면:
- 파일 복사 후 **컨테이너 자동 재시작**
- 변경사항이 즉시 서버에 반영됨

---

## 5단계: 추가 최적화

### Command 덮어쓰기

Dockerfile의 `CMD`를 수정하지 않고 docker-compose에서 덮어쓸 수 있습니다.

**사용 예시: nodemon으로 자동 재시작**

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080
    command: ["nodemon", "server.js"] # Dockerfile의 CMD를 덮어씀

    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - node_modules/
```

**nodemon이란?**

- Node.js 개발 도구
- 파일 변경 시 자동으로 서버 재시작
- `sync+restart` 대신 `sync`만 사용해도 됨

### Rebuild 액션 사용

특정 파일이 변경되면 **이미지를 다시 빌드**하도록 설정:

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        # 일반 파일은 동기화
        - action: sync+restart
          path: ./src
          target: /app/src

        # package.json 변경 시 재빌드
        - action: rebuild
          path: package.json
```

**언제 rebuild를 사용할까?**

- **패키지 설치가 필요한 경우**: `package.json`, `requirements.txt` 등
- **컴파일이 필요한 언어**: TypeScript, Go 등
- **환경 설정 파일 변경**: 이미지에 포함되는 설정 파일

---

## 🎓 핵심 요약

### 개발 워크플로우 진화

**1단계: 기본 (비효율적)**

```bash
docker compose down
docker build -t myapp .
docker compose up

```

**2단계: 자동 빌드**

```bash
docker compose down
docker compose up --build

```

**3단계: Watch 기능 (최적!)**

```bash
docker compose up --watch
# 이후 코드만 수정하면 자동 반영!

```

### 기능별 정리

| 기능                  | 용도           | 설정 위치              |
| --------------------- | -------------- | ---------------------- |
| **자동 빌드**         | 빌드를 자동화  | `build: .`             |
| **Graceful Shutdown** | 빠른 종료      | 코드 내 Signal 처리    |
| **Watch - Sync**      | 파일 자동 복사 | `action: sync`         |
| **Watch - Restart**   | 복사 + 재시작  | `action: sync+restart` |
| **Watch - Rebuild**   | 이미지 재빌드  | `action: rebuild`      |
| **Command 덮어쓰기**  | 개발용 명령어  | `command: [...]`       |

---

## 💻 실전 예제

### Node.js + Express 프로젝트

**프로젝트 구조:**

```
my-app/
├── src/
│   ├── server.js
│   └── routes/
├── package.json
├── Dockerfile
└── docker-compose.yml

```

**Dockerfile:**

```docker
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 8080
CMD ["node", "src/server.js"]

```

**docker-compose.yml:**

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080
    command: ["nodemon", "src/server.js"]

    develop:
      watch:
        # 소스 코드 변경 시 동기화 (nodemon이 재시작)
        - action: sync
          path: ./src
          target: /app/src

        # 의존성 변경 시 재빌드
        - action: rebuild
          path: package.json
```

**server.js (Graceful Shutdown 포함):**

```jsx
const express = require("express");
const app = express();

app.get("/", (req, res) => {
  res.send("Hello Docker!");
});

const server = app.listen(8080, () => {
  console.log("Server is running on port 8080");
});

// Graceful shutdown
process.on("SIGTERM", () => {
  console.log("SIGTERM received, closing server...");
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});

process.on("SIGINT", () => {
  console.log("SIGINT received, closing server...");
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});
```

**실행:**

```bash
# 개발 시작
docker compose up --watch

# 이제 src/ 안의 파일을 수정하면 자동 반영!
# package.json 수정 시 자동 재빌드!

```

---

## 🔧 문제 해결 (Troubleshooting)

### 문제 1: Watch가 작동하지 않음

**증상:** 파일을 수정해도 컨테이너에 반영되지 않음

**해결방법:**

```bash
# --watch 플래그 확인
docker compose up --watch

# build 옵션이 있는지 확인
# docker-compose.yml에 build: . 필요

```

### 문제 2: 변경사항이 브라우저에 나타나지 않음

**원인:** 파일은 복사되었지만 서버가 재시작되지 않음

**해결방법:**

1. `sync+restart` 사용
2. 또는 nodemon 같은 도구 사용

### 문제 3: 종료가 너무 느림 (10초 이상)

**원인:** Graceful shutdown 코드 없음

**해결방법:**

- Signal 처리 코드 추가
- DB 연결 등 리소스 정리 코드 작성

### 문제 4: node_modules가 계속 복사됨

**원인:** ignore 설정 누락

**해결방법:**

```yaml
watch:
  - action: sync
    path: .
    target: /app
    ignore:
      - node_modules/
      - .git/
      - dist/
```

또는 `.dockerignore` 파일 사용:

```
node_modules/
.git/
*.log

```

### 문제 5: 의존성 변경이 반영되지 않음

**원인:** rebuild 액션 없음

**해결방법:**

```yaml
watch:
  - action: rebuild
    path: package.json
```

---

## 🚀 다음 단계

이제 다음 주제를 학습할 준비가 되었습니다:

1. **Docker Network**: 컨테이너 간 통신
2. **Volume 심화**: 데이터 영속성과 성능 최적화
3. **Multi-stage Build**: 이미지 크기 최적화
4. **Production 배포**: Watch 없이 운영 환경 구성

---

## 💡 연습 문제

### 문제 1: 기본 Watch 설정

Python Flask 앱에 Watch 기능을 추가해보세요.

```yaml
services:
  flask-app:
    build: .
    ports:
      - 5000:5000
    # 여기에 develop/watch 설정 추가
```

<details>
<summary>정답 보기</summary>

```yaml
services:
  flask-app:
    build: .
    ports:
      - 5000:5000
    command: ["flask", "run", "--host=0.0.0.0", "--reload"]
    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - __pycache__/
            - *.pyc
        - action: rebuild
          path: requirements.txt

```

</details>

### 문제 2: Graceful Shutdown

다음 Express 서버에 Graceful Shutdown을 추가하세요.

```jsx
const express = require("express");
const app = express();

app.get("/", (req, res) => res.send("OK"));

app.listen(3000);
// SIGTERM, SIGINT 처리 코드 추가
```

<details>
<summary>정답 보기</summary>

```jsx
const express = require("express");
const app = express();

app.get("/", (req, res) => res.send("OK"));

const server = app.listen(3000);

process.on("SIGTERM", () => {
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});

process.on("SIGINT", () => {
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});
```

</details>

### 문제 3: 복합 Watch 설정

다음 요구사항을 만족하는 watch 설정을 작성하세요:

- `src/` 폴더의 JavaScript 파일 변경 시: sync만 실행 (nodemon 사용)
- `package.json` 변경 시: 이미지 재빌드
- `public/` 폴더의 정적 파일 변경 시: sync + restart

<details>
<summary>정답 보기</summary>

```yaml
develop:
  watch:
    - action: sync
      path: ./src
      target: /app/src

    - action: rebuild
      path: package.json

    - action: sync+restart
      path: ./public
      target: /app/public
```

</details>

---

## 📖 참고 자료

- [Docker Compose Watch 공식 문서](https://docs.docker.com/compose/file-watch/)
- [Signal 처리 (Node.js)](https://nodejs.org/api/process.html#signal-events)
- [Graceful Shutdown 패턴](https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html)

---

# 강의 스크립트

가끔 개발할 때 컨테이너로 띄워보면서 개발해보는 경우들이 있습니다.

- 팀원끼리 개발환경 아예 똑같이 맞출 때
- 배포전에 테스트하려고
- 그냥 편해서

이런 이유로 컨테이너로 미리보기 띄워서 개발하는 경우들이 있습니다.

하지만 이러면 귀찮은 점이 있는데

예를 들어 서버에서 "안녕"이라는 메세지를 "안녕123" 이런 식으로 바꿨습니다.

이 변동사항이 컨테이너에서도 잘 돌아가는지 확인하려면 어떻게 하게요?

1. docker compose down 하고

2. 웹서버 이미지 다시 만들고

3. docker compose up 해야합니다.

이러면 귀찮아서 도커 삭제하고 싶어질텐데 당연히 개선 방법이 몇개 있습니다.

> 빌드 자동화

가장 간단한 해결책은

docker compose 파일에 "항상 docker build 하고 나서 컨테이너 띄우세요" 이렇게 설정하면 됩니다.

```yaml
services:
  webserver:
    image: nodeserver:1
    build: .
    ports:
      - 8080:8080
```

**build: 도커파일경로** 입력하면 되는데

그럼 이제 docker compose up 할 때마다

해당 경로에 있는 도커파일을 가져다가 자동으로 docker build 명령을 수행해서 이미지를 생성하고

그 이미지로 컨테이너를 띄워줍니다.

하지만 docker compose up 말고

docker compose up --build

이런 명령어를 써야 자동으로 docker build 명령을 수행해줍니다.

그럼 아까와 다르게

1. docker compose down

2. docker compose up --build

입력하면 되니까 명령어가 1개 줄어들어서 편리해졌군요.

> graceful shutdown 기능

컨테이너 끄고 재시작하고 그런게 너무 느린경우들이 있습니다.

특히 웹서버하나 끄는데 10초넘게 걸린다면 그 이유는 **서버 꺼주는 코드를 안짜서** 그런 것일 뿐입니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EC%A0%9C%EB%AA%A9-%EC%97%86%EC%9D%8C2.png)

▲ 원래 docker 엔진이 컨테이너를 종료시킬 때 무슨 일이 일어나냐면

"좋은말할 때 알아서 끄라" 이런 식으로 메세지를 컨테이너의 프로그램으로 보냅니다.

그래서 프로그램은 그 경고성 메세지를 수신하면 알아서 종료하라고 코드짜놓으면 됩니다.

근데 종료하는 코드가 없거나 그러면 10초 정도 기다렸다가 강제로 꺼집니다.

그래서 종료하는 코드를 좀 작성해보도록 합시다.

```jsx
server.js;

const server = app.listen(어쩌구);

process.on("SIGTERM", () => {
  server.close(() => {
    console.log("HTTP server closed");
  });
});
process.on("SIGINT", () => {
  server.close(() => {
    console.log("HTTP server closed");
  });
});
```

그래서 웹서버에 SIGTERM 메세지가 들어오면 server.close()하라고 코드짰습니다.

- express의 기본 기능인 server.close() 를 사용하면 서버에 들어온 요청을 다 처리한 후에 이쁘게 알아서 꺼집니다.
- SIGTERM은 Docker 엔진이 컨테이너 종료할 때 보내는 "좋은 말할 때 알아서 끄라" 경고메세지입니다.
- SIGINT는 유저가 터미널에서 ctrl + c 누를 때 보내지는 메세지입니다.
- 참고로 터미널에 kill 1 입력하는 것도 SIGTERM 메세지 보내는 것입니다.

근데 나중에 서버에서 DB도 쓰고 그러면 서버를 끌 때 DB 연결 해제하는 것도 좋습니다.

이런 식으로 끄기 전에 이거저거 챙기는걸 멋있는 말로 graceful shutdown 이라고 합니다.

그래서 컨테이너로 돌릴 프로그램들은 자주 껐다켜지고 그럴 수 있으니까

컨테이너 안의 프로그램들에 graceful shutdown 잘해놨나 확인하는 것도 좋은 습관이니까 나중에 한번 챙겨봅시다.

> watch 기능

아까 "실행하기 전에 자동으로 빌드하세요" 이렇게 해놨는데 이것도 쓰다보면 오래걸려서 도커 삭제하고 싶어지는데

그럴 땐 시간내서 docker compose의 watch 기능 셋팅해두면

**특정 파일이 변경될 때마다 얘가 바로바로 컨테이너에 복사**를 해주기 때문에

그래서 이거 쓰면 매번 빌드 그딴거 할 필요가 없어서 매우 편리해집니다. 나름 최신기능임

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - node_modules/
        - action: rebuild
          path: package.json
```

우선 이런 식으로 작성해둡시다.

실시간 반영원하는 컨테이너에 develop: 넣고

watch: 넣고 시작하면 됩니다.

1. - action: sync 는 내 컴퓨터에 있던 파일 변경사항을 컨테이너로 복사해주라는 뜻입니다.

복붙말고 빌드, 컨테이너 재시작 등 다른 행위도 할 수 있는데 그건 나중에 확인해봅시다.

2. path: 에는 내 컴퓨터의 어떤 파일들 감시할건지 경로 적으면 됩니다.

3. target: 에는 컨테이너 어디에 변동사항을 복사할건지 경로 적으면 됩니다.

4. ignore: 안에는 변동사항을 복사할 필요가 없는 파일이나 폴더들 기록해두면 되는데 .dockerignore 파일 쓰고 있으면 따로 적을 필요는 없습니다.

그래서 위처럼 적으면 현재 폴더에 있는 파일들이 변동사항이 생겼을 때 app 폴더 안에 그대로 변동사항이 복사됩니다.

(참고) build: 옵션이 들어있어야 잘됩니다.

> 진짠지 테스트

테스트해보려면 docker compose down 했다가 다시 up 하면 될텐데

실은 **docker compose up --watch** 라고 명령을 줘야 watch 기능이 동작합니다.

이렇게 해두면 이제 코드 변경할 때마다 빌드하고 지랄할 필요가 없어지는군요.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EC%A0%9C%EB%AA%A9-%EC%97%86%EC%9D%8C12.png)

▲ 진짜 그런지 코드 수정하고 저장해봤는데

그러면 docker desktop 들어가서 컨테이너 들어가서 파일 검사해보면 소스코드가 진짜로 컨테이너에 실시간으로 복사된걸 볼 수 있습니다.

근데 브라우저 열어서 서버에 접속해보면.. 업데이트가 안되고있는데요?

왜 그러냐면 원래 로컬에서 개발할 때도 코드 수정했으면 **서버를 재시작해줘야** 반영이 됩니다.

그래서 그럴 뿐이라 서버도 재시작하라고 설정을 바꾸면 됩니다.

```yaml
services:
  webserver:
    build: .
    ports:
    - 8080:8080

    develop:
      watch:
        - action: sync+restart
          path: .
        (생략)
```

- action: sync+restart 이런 옵션을 넣으면 sync한 후에 컨테이너 재시작하라는 뜻입니다.

진짜 재시작까지 잘 되나 테스트해봅시다.

보통 nginx같은것도 설정을 바꾸면 한번 재시작해야 적용이 되기 때문에

코드 바꿀 때 마다 재시작이 필요한 컨테이너에 달아놓으면 개발할 때 편리합니다.

> command로 CMD 덮어쓰기

참고로 nodejs로 서버개발하는 경우에는

nodemon같은 라이브러리를 설치해서 nodemon server.js라는 명령어로 서버를 띄우면

파일변경이 생길 때마다 재시작을 알아서 해줘서 이런거 써도 됩니다.

그래서 명령어를 node server.js에서 nodemon server.js로 바꾸면 될텐데

Dockerfile가서 마지막 CMD 명령어를 수정하고 그런게 귀찮으면

docker compose파일에서 CMD 명령어를 덮어쓸 수 있습니다.

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    command: ["nodemon", "server.js"]
    develop: (생략)
```

command: 이런걸 서비스마다 넣을 수 있는데

그러면 그 서비스를 띄울 때 dockerfile에 있던 CMD 옆에 있는 명령어를 덮어쓰기할 수 있습니다.

그래서 docker compose 실행시 매번 다른 명령어 넣을 수 있으니까 필요할 때 사용합시다.

> action: rebuild

```yaml
services:
  webserver:
    build: .
    ports:
    - 8080:8080

    develop:
      watch:
        - action: rebuild
          path: package.json
        (생략)
```

- action: rebuild 집어넣으면

path에 있는 파일이나 폴더가 변동사항이 생기면 그냥 아예 docker build를 다시 해달라는 뜻입니다.

이미지 다시 만들라는 뜻임

그래서 Node.js 개발하는 경우에는 라이브러리같은거 설치하는거 변동사항이 생기면

이미지를 다시만드는게 깔끔하기 때문에 package.json파일 변경되면 rebuild하라고 코드짜놓는 경우들이 있습니다.

코드수정하고나서 항상 컴파일이 필요한 프로젝트들도 이걸 sync가 아니라 rebuild로 적는 경우들이 있습니다.

- action: 은 여러개 집어넣을 수 있으니 필요하면 사용합시다.

**오늘의 결론:**

내 코드를 컨테이너로 띄워보면서 실시간 코딩하고 싶으면 docker compose의 watch 기능을 꺼내씁시다.

컨테이너 껐다가 켤 일이 많다면 graceful shutdown 잘해놨나 확인합시다.

---
