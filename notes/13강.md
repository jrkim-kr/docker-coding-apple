# 13. Docker compose 3. 실시간 개발, graceful shutdown

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Compose의 Watch 기능을 활용한 실시간 개발 환경 구축
- 컨테이너의 Graceful Shutdown 구현
- 자동 빌드 설정으로 개발 워크플로우 개선
- 프로덕션과 동일한 환경에서 편리하게 개발하기

---

## 📚 사전 지식

- Docker Compose 기본 사용법
- Node.js 또는 기타 웹 프레임워크 기초
- Signal과 Process에 대한 기본 이해
- Dockerfile 작성 경험

---

## 1단계: 문제 상황 이해하기

### 컨테이너로 개발할 때의 불편함

컨테이너로 개발하는 이유는 여러 가지입니다:

- ✅ 팀원끼리 개발환경을 아예 똑같이 맞출 수 있음
- ✅ 배포 전에 프로덕션과 유사한 환경에서 테스트 가능
- ✅ 로컬 환경을 오염시키지 않음

하지만 **코드 변경사항을 확인하기 위한 과정이 너무 복잡**합니다.

### 기존 워크플로우의 문제점

코드를 수정했을 때:

```
1. docker compose down     ← 컨테이너 중지
2. docker build            ← 이미지 다시 빌드
3. docker compose up       ← 컨테이너 다시 시작

```

**"안녕" → "안녕123"** 이런 작은 변경도 매번 이 과정을 반복해야 합니다!

---

## 2단계: 자동 빌드 설정

### docker-compose.yml에 build 옵션 추가

가장 간단한 개선 방법은 자동 빌드 설정입니다.

```yaml
services:
  webserver:
    image: nodeserver:1
    build: . # Dockerfile 경로 지정
    ports:
      - 8080:8080
```

**`build: .`** 옵션을 추가하면:

- 해당 경로의 Dockerfile을 자동으로 찾음
- `docker compose up` 시 자동으로 이미지 빌드

### -build 플래그 사용하기

```bash
# 기존 명령어
docker compose up

# 자동 빌드 포함
docker compose up --build

```

이제 워크플로우가 다음처럼 단순해집니다:

```
1. docker compose down
2. docker compose up --build   ← 빌드 + 실행을 한 번에!

```

**명령어 하나가 줄어들었습니다!** 🎉

---

## 3단계: Graceful Shutdown 구현

### 왜 컨테이너 종료가 느릴까?

컨테이너를 끄는데 **10초 이상** 걸린다면?
→ **서버를 제대로 종료하는 코드가 없기 때문**입니다.

### Docker의 종료 프로세스

```
[Docker Engine]
    ↓
"좋은 말 할 때 알아서 꺼라" (SIGTERM 신호 전송)
    ↓
[Container/Program]
    ↓
종료 코드 없음? → 10초 대기 → 강제 종료 (SIGKILL)

```

### Signal 처리 코드 작성

**Node.js + Express 예제:**

```jsx
// server.js
const express = require("express");
const app = express();

// ... 라우트 설정 등 ...

const server = app.listen(8080, () => {
  console.log("Server running on port 8080");
});

// SIGTERM 신호 처리 (Docker가 보내는 종료 신호)
process.on("SIGTERM", () => {
  console.log("SIGTERM received. Shutting down gracefully...");
  server.close(() => {
    console.log("HTTP server closed");
    // 필요한 경우 DB 연결 해제 등 추가
    process.exit(0);
  });
});

// SIGINT 신호 처리 (Ctrl+C)
process.on("SIGINT", () => {
  console.log("SIGINT received. Shutting down gracefully...");
  server.close(() => {
    console.log("HTTP server closed");
    process.exit(0);
  });
});
```

### 각 부분 설명

- **`SIGTERM`**: Docker가 컨테이너를 중지할 때 보내는 신호
- **`SIGINT`**: 터미널에서 `Ctrl+C`를 눌렀을 때 보내는 신호
- **`server.close()`**: 현재 처리 중인 요청을 완료한 후 서버 종료
- **`process.exit(0)`**: 프로세스를 정상적으로 종료

### DB 사용 시 추가 처리

```jsx
process.on("SIGTERM", () => {
  server.close(async () => {
    console.log("HTTP server closed");

    // DB 연결 해제
    await db.disconnect();
    console.log("Database connection closed");

    process.exit(0);
  });
});
```

---

## 4단계: Watch 기능 설정 (핵심!)

### Watch 기능이란?

Docker Compose의 **Watch 기능**은:

- 파일 변경을 감지하면 **자동으로 컨테이너에 반영**
- 빌드 없이 즉시 변경사항 확인 가능
- 개발 속도를 획기적으로 향상

### 기본 Sync 설정

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - node_modules/
```

**각 옵션 설명:**

| 옵션           | 설명                         |
| -------------- | ---------------------------- |
| `action: sync` | 파일 변경 시 컨테이너로 복사 |
| `path: .`      | 감시할 로컬 경로 (현재 폴더) |
| `target: /app` | 컨테이너 내부의 대상 경로    |
| `ignore`       | 제외할 파일/폴더 목록        |

### Watch 실행하기

```bash
docker compose up --watch

```

이제 코드를 수정하고 저장하면:

1. Watch가 변경 감지
2. 자동으로 컨테이너에 복사
3. **빌드 없이 즉시 반영!**

### 주의사항

파일은 복사되지만, **서버는 자동으로 재시작되지 않습니다!**

브라우저에서 확인해도 변경사항이 반영되지 않는 이유:

- 로컬 개발도 코드 수정 후 서버 재시작 필요
- 컨테이너도 마찬가지!

### Sync + Restart 설정

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        - action: sync+restart
          path: .
          target: /app
          ignore:
            - node_modules/
```

- **`sync+restart`**를 사용하면:
- 파일 복사 후 **컨테이너 자동 재시작**
- 변경사항이 즉시 서버에 반영됨

---

## 5단계: 추가 최적화

### Command 덮어쓰기

Dockerfile의 `CMD`를 수정하지 않고 docker-compose에서 덮어쓸 수 있습니다.

**사용 예시: nodemon으로 자동 재시작**

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080
    command: ["nodemon", "server.js"] # Dockerfile의 CMD를 덮어씀

    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - node_modules/
```

**nodemon이란?**

- Node.js 개발 도구
- 파일 변경 시 자동으로 서버 재시작
- `sync+restart` 대신 `sync`만 사용해도 됨

### Rebuild 액션 사용

특정 파일이 변경되면 **이미지를 다시 빌드**하도록 설정:

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080

    develop:
      watch:
        # 일반 파일은 동기화
        - action: sync+restart
          path: ./src
          target: /app/src

        # package.json 변경 시 재빌드
        - action: rebuild
          path: package.json
```

**언제 rebuild를 사용할까?**

- **패키지 설치가 필요한 경우**: `package.json`, `requirements.txt` 등
- **컴파일이 필요한 언어**: TypeScript, Go 등
- **환경 설정 파일 변경**: 이미지에 포함되는 설정 파일

---

## 🎓 핵심 요약

### 개발 워크플로우 진화

**1단계: 기본 (비효율적)**

```bash
docker compose down
docker build -t myapp .
docker compose up

```

**2단계: 자동 빌드**

```bash
docker compose down
docker compose up --build

```

**3단계: Watch 기능 (최적!)**

```bash
docker compose up --watch
# 이후 코드만 수정하면 자동 반영!

```

### 기능별 정리

| 기능                  | 용도           | 설정 위치              |
| --------------------- | -------------- | ---------------------- |
| **자동 빌드**         | 빌드를 자동화  | `build: .`             |
| **Graceful Shutdown** | 빠른 종료      | 코드 내 Signal 처리    |
| **Watch - Sync**      | 파일 자동 복사 | `action: sync`         |
| **Watch - Restart**   | 복사 + 재시작  | `action: sync+restart` |
| **Watch - Rebuild**   | 이미지 재빌드  | `action: rebuild`      |
| **Command 덮어쓰기**  | 개발용 명령어  | `command: [...]`       |

---

## 💻 실전 예제

### Node.js + Express 프로젝트

**프로젝트 구조:**

```
my-app/
├── src/
│   ├── server.js
│   └── routes/
├── package.json
├── Dockerfile
└── docker-compose.yml

```

**Dockerfile:**

```docker
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 8080
CMD ["node", "src/server.js"]

```

**docker-compose.yml:**

```yaml
services:
  webserver:
    build: .
    ports:
      - 8080:8080
    command: ["nodemon", "src/server.js"]

    develop:
      watch:
        # 소스 코드 변경 시 동기화 (nodemon이 재시작)
        - action: sync
          path: ./src
          target: /app/src

        # 의존성 변경 시 재빌드
        - action: rebuild
          path: package.json
```

**server.js (Graceful Shutdown 포함):**

```jsx
const express = require("express");
const app = express();

app.get("/", (req, res) => {
  res.send("Hello Docker!");
});

const server = app.listen(8080, () => {
  console.log("Server is running on port 8080");
});

// Graceful shutdown
process.on("SIGTERM", () => {
  console.log("SIGTERM received, closing server...");
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});

process.on("SIGINT", () => {
  console.log("SIGINT received, closing server...");
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});
```

**실행:**

```bash
# 개발 시작
docker compose up --watch

# 이제 src/ 안의 파일을 수정하면 자동 반영!
# package.json 수정 시 자동 재빌드!

```

---

## 🔧 문제 해결 (Troubleshooting)

### 문제 1: Watch가 작동하지 않음

**증상:** 파일을 수정해도 컨테이너에 반영되지 않음

**해결방법:**

```bash
# --watch 플래그 확인
docker compose up --watch

# build 옵션이 있는지 확인
# docker-compose.yml에 build: . 필요

```

### 문제 2: 변경사항이 브라우저에 나타나지 않음

**원인:** 파일은 복사되었지만 서버가 재시작되지 않음

**해결방법:**

1. `sync+restart` 사용
2. 또는 nodemon 같은 도구 사용

### 문제 3: 종료가 너무 느림 (10초 이상)

**원인:** Graceful shutdown 코드 없음

**해결방법:**

- Signal 처리 코드 추가
- DB 연결 등 리소스 정리 코드 작성

### 문제 4: node_modules가 계속 복사됨

**원인:** ignore 설정 누락

**해결방법:**

```yaml
watch:
  - action: sync
    path: .
    target: /app
    ignore:
      - node_modules/
      - .git/
      - dist/
```

또는 `.dockerignore` 파일 사용:

```
node_modules/
.git/
*.log

```

### 문제 5: 의존성 변경이 반영되지 않음

**원인:** rebuild 액션 없음

**해결방법:**

```yaml
watch:
  - action: rebuild
    path: package.json
```

---

## 🚀 다음 단계

이제 다음 주제를 학습할 준비가 되었습니다:

1. **Docker Network**: 컨테이너 간 통신
2. **Volume 심화**: 데이터 영속성과 성능 최적화
3. **Multi-stage Build**: 이미지 크기 최적화
4. **Production 배포**: Watch 없이 운영 환경 구성

---

## 💡 연습 문제

### 문제 1: 기본 Watch 설정

Python Flask 앱에 Watch 기능을 추가해보세요.

```yaml
services:
  flask-app:
    build: .
    ports:
      - 5000:5000
    # 여기에 develop/watch 설정 추가
```

<details>
<summary>정답 보기</summary>

```yaml
services:
  flask-app:
    build: .
    ports:
      - 5000:5000
    command: ["flask", "run", "--host=0.0.0.0", "--reload"]
    develop:
      watch:
        - action: sync
          path: .
          target: /app
          ignore:
            - __pycache__/
            - *.pyc
        - action: rebuild
          path: requirements.txt

```

</details>

### 문제 2: Graceful Shutdown

다음 Express 서버에 Graceful Shutdown을 추가하세요.

```jsx
const express = require("express");
const app = express();

app.get("/", (req, res) => res.send("OK"));

app.listen(3000);
// SIGTERM, SIGINT 처리 코드 추가
```

<details>
<summary>정답 보기</summary>

```jsx
const express = require("express");
const app = express();

app.get("/", (req, res) => res.send("OK"));

const server = app.listen(3000);

process.on("SIGTERM", () => {
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});

process.on("SIGINT", () => {
  server.close(() => {
    console.log("Server closed");
    process.exit(0);
  });
});
```

</details>

### 문제 3: 복합 Watch 설정

다음 요구사항을 만족하는 watch 설정을 작성하세요:

- `src/` 폴더의 JavaScript 파일 변경 시: sync만 실행 (nodemon 사용)
- `package.json` 변경 시: 이미지 재빌드
- `public/` 폴더의 정적 파일 변경 시: sync + restart

<details>
<summary>정답 보기</summary>

```yaml
develop:
  watch:
    - action: sync
      path: ./src
      target: /app/src

    - action: rebuild
      path: package.json

    - action: sync+restart
      path: ./public
      target: /app/public
```

</details>

---

## 📖 참고 자료

- [Docker Compose Watch 공식 문서](https://docs.docker.com/compose/file-watch/)
- [Signal 처리 (Node.js)](https://nodejs.org/api/process.html#signal-events)
- [Graceful Shutdown 패턴](https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html)

---
