11. Docker compose 1. 서비스 작성하기

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Compose의 필요성과 장점 이해
- docker-compose.yml 파일 작성 및 실행
- 여러 컨테이너를 한 번에 관리
- 환경변수와 네트워크 설정
- 컨테이너 실행 순서 제어

---

## 📚 사전 지식

- Docker 기본 명령어 (run, build, ps)
- 이전 강의의 Nginx 설정 경험
- 간단한 포트와 네트워크 개념

---

## 1단계: Docker Compose가 필요한 이유

### 문제 상황

지금까지 컨테이너를 실행할 때 이런 식으로 했습니다:

```bash
docker run -d -p 8080:8080 --name my-webserver nodeserver:1
docker run -d -p 80:80 --name my-nginx nginx:1

```

컨테이너가 많아지면 명령어가 점점 길어지고 복잡해집니다:

```bash
docker run -d \
  -p 8080:8080 \
  --name my-webserver \
  -e DB_HOST=localhost \
  -e DB_PORT=5432 \
  -e DB_USER=admin \
  --network my-network \
  nodeserver:1

```

### 해결책: Docker Compose

Docker Compose를 사용하면:

- ✅ 모든 설정을 **한 파일**에 정리
- ✅ 여러 컨테이너를 **한 번에** 실행/중지
- ✅ 명령어 **재사용** 가능
- ✅ 팀원들과 **공유** 쉬움

---

## 2단계: Docker Compose 기본 사용법

### 설치 확인

Docker Desktop을 설치했다면 이미 설치되어 있습니다!

```bash
docker compose version

```

### 사용 흐름

```
1. docker-compose.yml 파일 작성
         ↓
2. docker compose up -d 실행
         ↓
3. 컨테이너들이 자동으로 실행됨!

```

---

## 3단계: YAML 파일 작성하기

### YAML이 뭔가요?

설정을 저장하는 파일 형식입니다. JSON과 비슷하지만 더 읽기 쉽습니다.

**기본 문법:**

```yaml
데이터이름: 값 # 키: 값 형식
하위데이터: # 콜론(:) 뒤에는 반드시 공백
  항목1: 값1 # 들여쓰기로 계층 구조 표현 (스페이스 2칸)
  항목2: 값2 # 탭(Tab)이 아닌 스페이스만 사용!
```

**중요:** 인덴트(들여쓰기)가 매우 중요합니다! 스페이스 2칸을 사용하세요.

### 첫 번째 docker-compose.yml

프로젝트 폴더를 만들고 `docker-compose.yml` 파일을 생성하세요:

```yaml
services: # 최상위 키워드: 컨테이너들을 정의하는 섹션
  webserver: # 서비스 이름 (컨테이너 이름처럼 사용됨)
    image: nodeserver:1 # 사용할 Docker 이미지 이름
    ports: # 포트 매핑 설정
      - 8080:8080 # - 는 리스트 항목을 의미 (호스트포트:컨테이너포트)
```

**각 줄 설명:**

- `services:` - 실행할 컨테이너들을 정의하는 최상위 섹션
- `webserver:` - 서비스(컨테이너)의 이름 (원하는 대로 작명 가능)
- `image:` - 사용할 Docker 이미지 (docker run의 마지막 인자와 동일)
- `ports:` - 포트 매핑 (docker run의 -p 옵션과 동일)
- `8080:8080` - 리스트 항목, 왼쪽은 호스트 포트, 오른쪽은 컨테이너 포트

### 실행하기

```bash
# 컨테이너 실행 (백그라운드)
docker compose up -d

# 실행 중인 컨테이너 확인
docker compose ps

# 컨테이너 중지
docker compose stop

# 컨테이너 중지 + 삭제
docker compose down

```

---

## 4단계: 환경변수 설정

### 방법 1: 직접 입력

```yaml
services: # 컨테이너들을 정의하는 섹션
  webserver: # 서비스 이름
    image: nodeserver:1 # 사용할 이미지
    ports: # 포트 매핑 리스트
      - 8080:8080 # 호스트:컨테이너 포트
    environment: # 환경변수 섹션 (docker run의 -e 옵션)
      - DB_HOST=localhost # 환경변수 형식: 이름=값
      - DB_PORT=5432 # 각 환경변수는 - 로 시작하는 리스트 항목
      - DB_USER=admin # 컨테이너 내부에서 이 변수들을 사용 가능
      - DB_PASSWORD=secret123 # 민감한 정보는 .env 파일 사용 권장
```

### 방법 2: .env 파일 사용 (권장)

같은 폴더에 `.env` 파일 생성:

```bash
# .env 파일
POSTGRES_USER=admin              # 환경변수 이름=값
POSTGRES_PASSWORD=secret123      # .env 파일은 Git에 올리지 말 것!
POSTGRES_DB=mydb                 # .gitignore에 추가 필수

```

docker-compose.yml에서 사용:

```yaml
services: # 서비스 정의 시작
  database: # 데이터베이스 서비스 이름
    image: postgres:latest # PostgreSQL 이미지 사용
    environment: # 환경변수 설정
      - POSTGRES_USER=${POSTGRES_USER} # ${변수명}으로 .env 파일의 값 참조
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD} # .env 파일에서 자동으로 값을 가져옴
      - POSTGRES_DB=${POSTGRES_DB} # Docker Compose가 자동으로 치환
```

### 변수 치환(Variable Substitution) 문법 상세 설명

`${}` 문법은 **변수 치환(Variable Substitution)** 또는 **변수 보간(Variable Interpolation)**이라고 부릅니다.

**실제 사용 예시:**

.env 파일:

```bash
# .env
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=admin
DB_PASSWORD=secret123
APP_PORT=8080
NODE_ENV=production

```

docker-compose.yml:

```yaml
services:
  backend:
    image: nodeserver:1
    ports:
      - "${APP_PORT}:8080" # 변수 치환: .env의 APP_PORT 사용
    environment:
      - NODE_ENV=${NODE_ENV} # production
      - DB_HOST=${DB_HOST} # localhost
      - DB_PORT=${DB_PORT} # 5432
      - DB_NAME=${DB_NAME} # myapp
      - DB_USER=${DB_USER} # admin
      - DB_PASSWORD=${DB_PASSWORD} # secret123
      - API_URL=http://${DB_HOST}:${APP_PORT}/api # 변수 조합
      - LOG_LEVEL=${LOG_LEVEL:-debug} # .env에 없으면 debug 사용
```

**주의사항:**

1. `.env` 파일은 `docker-compose.yml`과 같은 폴더에 있어야 합니다
2. 포트 번호 등 숫자가 들어가는 곳에 변수를 사용할 때는 전체를 따옴표로 감싸야 합니다: `"${PORT}:5432"`
3. `.env` 파일은 절대 Git에 올리지 마세요 (.gitignore에 추가)
4. `.env.example` 파일을 만들어 변수 목록을 공유하면 좋습니다

**.env.example 예시:**

```bash
# .env.example - Git에 올려도 되는 예시 파일
POSTGRES_USER=your_username
POSTGRES_PASSWORD=your_password
POSTGRES_DB=your_database
PORT=5432

```

**장점:**

- 민감한 정보를 분리 관리
- 환경별로 다른 설정 사용 가능 (개발/운영)
- .gitignore로 보안 유지
- 팀원들과 설정 구조 공유 가능
- 하드코딩 없이 유연한 설정 관리

---

## 5단계: 여러 컨테이너 실행하기

### Nginx + 웹서버 함께 실행

```yaml
services: # 여러 서비스를 정의할 수 있음
  webserver: # 첫 번째 서비스: 웹서버
    image: nodeserver:1 # Node.js 서버 이미지
    ports: # 포트 매핑
      - 8080:8080 # 8080번 포트 노출

  nginx: # 두 번째 서비스: Nginx (services와 같은 들여쓰기 레벨)
    image: nginx:1 # Nginx 이미지
    ports: # 포트 매핑
      - 80:80 # 80번 포트 노출
```

이제 `docker compose up -d` 한 번으로 **두 컨테이너가 동시에** 실행됩니다!

### 구조 이해하기

```
docker-compose.yml
├── services                 (최상위 키워드)
    ├── webserver           (서비스 1)
    │   ├── image: nodeserver:1
    │   └── ports: 8080:8080
    │
    └── nginx               (서비스 2)
        ├── image: nginx:1
        └── ports: 80:80

```

---

## 6단계: 네트워크 자동 연결

### 자동 네트워크 생성

Docker Compose는 **자동으로 네트워크를 생성**하고 모든 컨테이너를 연결합니다.

```yaml
services: # 이 services 안의 모든 컨테이너는
  webserver: # 자동으로 같은 네트워크에 연결됨
    image: nodeserver:1 # 네트워크 이름: 폴더명_default
    ports: # (예: myproject_default)
      - 8080:8080

  nginx: # 같은 네트워크 안에 있어서
    image: nginx:1 # 서로 서비스 이름으로 통신 가능
    ports:
      - 80:80
```

위 설정만으로:

- `webserver`는 `http://nginx`로 nginx에 접근 가능
- `nginx`는 `http://webserver:8080`로 웹서버에 접근 가능

### 이전 강의와 연결

8강에서 Nginx 설정 파일을 이렇게 수정할 수 있습니다:

```
server {
    listen 80;
    location / {
        # localhost:8080 대신 서비스 이름 사용!
        proxy_pass http://webserver:8080;
        proxy_set_header Host $host;
    }
}

```

**핵심:** 컨테이너 이름(서비스 이름)으로 서로를 찾을 수 있습니다!

---

## 7단계: 컨테이너 실행 순서 제어

### 왜 순서가 중요할까?

실제 애플리케이션에서는 의존성이 있습니다:

```
데이터베이스 → 웹서버 → Nginx
   (먼저)     (그 다음)   (마지막)

```

### depends_on 사용하기

```yaml
services: # 3개의 서비스 정의
  database: # 1번: 데이터베이스 (가장 먼저 시작)
    image: postgres:latest # PostgreSQL 이미지
    environment: # 환경변수 설정
      - POSTGRES_PASSWORD=secret # DB 패스워드

  webserver: # 2번: 웹서버 (database 다음)
    image: nodeserver:1 # Node.js 서버
    ports: # 포트 노출
      - 8080:8080
    depends_on: # 의존성 정의 시작
      - database # database 서비스가 먼저 시작되어야 함
        # (리스트 형태로 여러 개 지정 가능)

  nginx: # 3번: Nginx (webserver 다음)
    image: nginx:1 # Nginx 이미지
    ports: # 포트 노출
      - 80:80
    depends_on: # 의존성 정의
      - webserver # webserver가 먼저 시작되어야 함
```

**실행 순서:**

1. `database` 컨테이너 시작
2. `database`가 실행되면 `webserver` 시작
3. `webserver`가 실행되면 `nginx` 시작

**주의:** depends_on은 컨테이너 시작 순서만 보장합니다. 애플리케이션이 실제로 준비되었는지는 확인하지 않습니다!

---

## 🎓 서비스 개념 이해하기

### 서비스란?

**서비스 = 컨테이너 실행 가이드**

```yaml
services: # 서비스들을 정의하는 섹션
  webserver: # 서비스 이름 (가이드의 제목)
    image: nodeserver:1 # 어떤 이미지를 사용할지
    ports: # 어떤 포트를 열지
      - 8080:8080
    environment: # 어떤 환경변수를 넣을지
      - NODE_ENV=production # 이 모든 설정이 "서비스 정의"
```

### 왜 "서비스"라고 부를까?

- 실제 운영 환경에서는 같은 컨테이너를 여러 개 실행합니다
- 서비스 단위로 **스케일링**(확장)이 가능합니다
- Kubernetes, Docker Swarm 등에서도 비슷한 개념을 사용합니다

### 서비스 복제하기 (고급)

```yaml
services: # 서비스 정의
  webserver: # 웹서버 서비스
    image: nodeserver:1 # 사용할 이미지
    ports: # 포트 설정
      - 8080:8080
    deploy: # 배포 설정 (Docker Swarm/Kubernetes용)
      mode: replicated # 복제 모드 사용
      replicas: 3 # 동일한 컨테이너를 3개 실행
```

```bash
# 복제 실행
docker compose --compatibility up

```

---

## 🎓 핵심 요약

### Docker Compose의 핵심

1. **한 파일에 모든 설정** 정리 (docker-compose.yml)
2. **한 명령어로 실행/중지** (docker compose up/down)
3. **자동 네트워크 연결** (서비스 이름으로 통신)
4. **실행 순서 제어** (depends_on)
5. **환경변수 관리** (.env 파일과 변수 치환)

### 주요 명령어

```bash
docker compose up -d      # 시작 (백그라운드)
docker compose ps         # 상태 확인
docker compose logs       # 로그 보기
docker compose stop       # 중지
docker compose down       # 중지 + 삭제
docker compose restart    # 재시작

```

---

## 🔥 실전 예제

### 완전한 웹 애플리케이션 스택

```yaml
services: # 서비스 정의 시작
  # 데이터베이스 서비스
  database: # 서비스 이름: database
    image: postgres:latest # PostgreSQL 최신 버전 사용
    environment: # 환경변수 설정
      - POSTGRES_PASSWORD=secret123 # DB 관리자 비밀번호
      - POSTGRES_DB=myapp # 생성할 데이터베이스 이름
    volumes: # 볼륨 마운트 (데이터 영구 저장)
      - db-data:/var/lib/postgresql/data # 볼륨이름:컨테이너경로

  # 백엔드 서버 서비스
  backend: # 서비스 이름: backend
    image: nodeserver:1 # Node.js 서버 이미지
    ports: # 포트 매핑
      - 8080:8080 # 외부에서 8080으로 접근
    environment: # 환경변수 설정
      - DB_HOST=database # DB 호스트 (서비스 이름 사용!)
      - DB_PORT=5432 # PostgreSQL 기본 포트
      - DB_NAME=myapp # 접속할 DB 이름
    depends_on: # 의존성 정의
      - database # database가 먼저 시작되어야 함

  # 리버스 프록시 서비스
  nginx: # 서비스 이름: nginx
    image: nginx:1 # Nginx 이미지
    ports: # 포트 매핑
      - 80:80 # HTTP 기본 포트
    depends_on: # 의존성 정의
      - backend # backend가 먼저 시작되어야 함

volumes: # 최상위 volumes 섹션
  db-data:# 볼륨 이름 정의
  # Docker가 자동으로 생성 및 관리
```

**프로젝트 구조:**

```
my-project/
├── docker-compose.yml
├── .env
└── nginx/
    └── nginx.conf

```

---

## 💡 연습 문제

### 문제 1: 기본 설정

다음 조건을 만족하는 docker-compose.yml을 작성하세요:

- Redis 컨테이너 (이미지: redis:latest, 포트: 6379)
- 웹서버 컨테이너 (이미지: nodeserver:1, 포트: 3000)

**정답:**

```yaml
services: # 서비스 정의 시작
  redis: # Redis 서비스 이름
    image: redis:latest # Redis 공식 이미지 최신 버전
    ports: # 포트 매핑
      - 6379:6379 # Redis 기본 포트

  webserver: # 웹서버 서비스 이름
    image: nodeserver:1 # Node.js 서버 이미지
    ports: # 포트 매핑
      - 3000:3000 # 3000번 포트로 접근
```

---

### 문제 2: 의존성 설정

위 설정에서 webserver가 redis 다음에 실행되도록 수정하세요.

**정답:**

```yaml
services: # 서비스 정의
  redis: # Redis 서비스 (먼저 시작)
    image: redis:latest # Redis 이미지
    ports: # 포트 설정
      - 6379:6379

  webserver: # 웹서버 서비스 (나중에 시작)
    image: nodeserver:1 # Node.js 이미지
    ports: # 포트 설정
      - 3000:3000
    depends_on: # 의존성 설정 시작
      - redis # redis가 먼저 실행되어야 함
```

---

### 문제 3: 환경변수

webserver에 다음 환경변수를 추가하세요:

- NODE_ENV=production
- REDIS_HOST=redis
- REDIS_PORT=6379

**정답:**

```yaml
services: # 서비스 정의
  redis: # Redis 서비스
    image: redis:latest # Redis 이미지
    ports: # 포트 매핑
      - 6379:6379

  webserver: # 웹서버 서비스
    image: nodeserver:1 # Node.js 이미지
    ports: # 포트 매핑
      - 3000:3000
    environment: # 환경변수 섹션 추가
      - NODE_ENV=production # 운영 환경 설정
      - REDIS_HOST=redis # Redis 호스트 (서비스 이름!)
      - REDIS_PORT=6379 # Redis 포트 번호
    depends_on: # 의존성 설정
      - redis # Redis가 먼저 시작
```

---

## 💭 자주 묻는 질문

**Q: docker run과 docker compose의 차이는?**

- `docker run`: 컨테이너 하나씩 수동 실행
- `docker compose`: 여러 컨테이너를 설정 파일로 자동 관리

**Q: 네트워크를 별도로 만들어야 하나요?**

- 아니요. Docker Compose가 자동으로 만들어줍니다.

**Q: 컨테이너가 시작은 되는데 바로 종료돼요**

- `docker compose logs [서비스명]`으로 로그를 확인하세요
- 애플리케이션 내부 오류일 가능성이 높습니다

**Q: depends_on을 써도 연결 오류가 나요**

- depends_on은 시작 순서만 보장합니다
- 애플리케이션이 준비되는 걸 기다리는 건 아닙니다
- healthcheck 옵션을 추가로 사용하세요

---

## 📚 VSCode 팁

Docker 확장 프로그램 설치하면:

- YAML 자동완성
- 문법 검사
- 컨테이너 상태 확인
- 로그 바로 보기

**설치 방법:** VSCode 확장 탭에서 "Docker" 검색

---

# 강의 스크립트

docker run 명령어가 슬슬 길어지면 docker를 버리고 싶어집니다.

그게 싫으면 명령어들을 한 파일에 입력해놓고 그걸 실행하는 식으로 코드짜놓으셔도 됩니다.

그럴려면 shell script 이런거 짜서 실행해도 되긴 하는데

docker compose 라는 프로그램을 쓰면 훨씬 쉽게 구현가능합니다.

따로 설치할 필요는 없고 docker desktop 설치할 때 같이 설치됩니다.

> docker compose 사용하는 법

1. docker-compose.yml 파일 하나 만들어서

2. 거기다가 docker run 어쩌구 쓰던 명령어들을 쭉 나열하고

3. 이제 터미널에서 docker compose up 이라고 입력하면 이 파일에 있던 내용이 쭉 실행됩니다.

편리하죠?

하지만 docker compose 문법 + yaml 파일형식에 맞게 .yml 파일을 채워야합니다.

> services

.yml 파일이 뭐냐면 일단 데이터 저장하는 용도의 파일형식입니다.

.json 아는 분들은 그 파일이랑 비슷한 것이라고 생각하면 됩니다.

.yml 파일은 **데이터이름 : 값** 이런 식으로 저장합니다.

어떤 데이터에 속하는 하위 데이터는 인덴트 넣고 데이터이름 : 값 적으면 끝입니다.

```
(docker-compose.yml)

services:
  컨테이너이름:
    image: 이미지이름
    ports:
      - 내컴퓨터포트:컨테이너포트
```

그래서 아무데나 docker-compose.yml 파일 만들어서 이렇게 작성해봅시다.

services: 라고 적고 인덴트 넣어서 하위 항목으로 **컨테이너 이름**을 하나 작명합시다.

정확히는 서비스 이름인데 일단은 컨테이너 이름이라고 부릅시다.

그 다음에 하위 항목으로

**image: 이미지이름** 적으면 이 이미지를 컨테이너로 띄워줍니다.

**ports:** 하위항목으로 포트바인딩 어떻게 할 건지도 정할 수 있습니다.

- VSCode 에디터 쓰는 분들은 이런거 작성할 때 Docker 부가기능 설치하면 편리할 수 있습니다.
- 참고로 예전엔 도커 version 부터 맨 위에 넣고 시작했는데 요즘은 그럴 필요 없습니다.

> 환경변수 넣으려면

```
(docker-compose.yml)

services:
  컨테이너이름:
    image: 이미지이름
    ports:
      - 내컴퓨터포트:컨테이너포트
    environment:
      - 환경변수이름=값
      - 환경변수이름=값
```

환경 변수는 이런식으로 하나하나 적어두면 됩니다.

하나하나 적기 귀찮으면 다른 파일에 있는걸 끌어다가 쓸 수 있습니다.

```makefile
(.env)

POSTGRES_USER=admin
```

예를 들어 우리가 코딩할 때 .env파일에 환경변수를 가끔 적어놓기도 합니다.

이 파일에 있는걸 docker compose 설정파일에서 그대로 가져올 수도 있습니다.

```yaml
(docker-compose.yml)

  environment:
    - POSTGRES_USER: ${POSTGRES_USER}
```

그럴려면 ${} 쓰고 .env 파일에 있는 환경변수 이름 적어주면 되겠습니다.

.env 파일이 여러개 있으면 그 중에 어디서 가져올건지 명시하는 기능도 있는데 필요할 때 찾아씁시다.

> 띄우는 명령어는

```yaml
(docker-compose.yml)

services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080
```

그래서 전에 만들어 놓은 웹서버 띄우고 싶어서 이렇게 작성해놨습니다.

```
docker compose up -d
docker compose stop
docker compose down
```

docker compose 파일을 기반으로 컨테이너를 띄우고 ,정지하고, 삭제하려면 차례로 이런걸 입력합시다.

> 다른 컨테이너 띄우기

웹서버는 잘 뜨는 것 같은데

nginx같은 다른 컨테이너를 하나 더 띄우고 싶으면

service: 하위 항목을 더 정의하면 됩니다.

그니까 띄울 이미지마다 서비스 하나씩 만들면 된다고 생각하면 됩니다.

```yaml
(docker-compose.yml)

services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080

  nginx:
    image: nginx:1
    ports:
      - 80:80
```

그래서 저장하고 docker compose down 한 다음에 docker compose up -d 해보면

컨테이너 2개가 동시에 잘 뜹니다.

> 네트워크

컨테이너간 통신이 필요해서 네트워크가 필요하다면

실은 네트워크를 따로 만들고 그럴 필요가 없습니다.

services: 하위항목에 있는 컨테이너들은

자동으로 네트워크 하나 만들어서 거기 전부 넣어주기 때문에 그렇습니다.

그리고 네트워크 안에 있는 컨테이너끼리 서로 찾으려면

**IP주소 혹은 컨테이너 이름 (서비스 이름)**을 기재하면 되니까 알아서 nginx와 웹서버 연결 해보시면 되겠습니다.

> 여러 컨테이너들이 서로 dependency가 있으면?

컨테이너들을 띄우다보면

어떤 컨테이너는 다른 컨테이너가 떠있어야 제대로 동작하는 경우가 있습니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EA%B7%B8%EB%A6%BC1.png)

예를 들어 nginx는 "웹서버에 보내주세요~"

웹서버는 "DB에 연결해주세요~"

이런 식으로 코드가 짜여져있는게 일반적입니다.

이런 경우에는 DB먼저 띄우고 웹서버 띄우고 그 다음에 nginx 띄우면 좀 안정적이지 않겠습니까.

그리고 그래야 잘 돌아갈 것 같습니다.

```yaml
(docker-compose.yml)

services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080

  nginx:
    image: nginx:1
    ports:
      - 80:80
    depends_on:
      - webserver
```

depends_on: 하위 항목으로 다른 서비스 이름을 기재할 수 있는데

그러면 위의 코드에선 nginx는 webserver에 의존한다는 뜻입니다.

그럼 webserver 컨테이너가 먼저 실행된 다음 nginx 컨테이너가 실행됩니다.

그래서 컨테이너 실행 순서를 결정하고 싶으면 depends_on: 을 사용해봅시다.

> 서비스

docker compose에선 컨테이너를 "서비스" 안에 작성하는데

서비스가 뭐냐면 컨테이너를 어떻게 띄울지 정의하는 일종의 가이드같은 개념입니다.

```yaml
(docker-compose.yml)

services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080
```

이미지가 있으면

- 어떤 포트를 열지
- 어떤 환경변수를 넣을지
- 컨테이너 이름은 어떻게 지을지

이런걸 결정해야 이미지를 컨테이너로 실행할 수 있지 않습니까

이런 컨테이너 실행 가이드를 docker compose에서 서비스라고 부릅니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EA%B7%B8%EB%A6%BC2.png)

서비스라는 개념이 중요한데

왜냐면 여러분이 나중에 컨테이너 수백개를 띄우게 되면 그걸 관리하기 위한 프로그램을 따로 사용합니다.

Docker swarm, Kubernetes, AWS ECS 이런게 있는데

이런걸 써도 항상 서비스와 비슷한 걸 작성한 뒤에 컨테이너들을 띄우게 됩니다.

그래서 잘 기억해둡시다.

서비스를 만들어두면 장점이 뭐냐면

컨테이너 설정을 한 눈에 볼 수 있는 것도 있는데

나중에 같은 컨테이너 여러개가 필요할 때도 편리해집니다.

"서비스에 써있는 내용대로 컨테이너 여러개 복사해서 띄워주세요" 이런게 가능해지니까요.

```yaml
(docker-compose.yml)

services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080
    deploy:
      mode: replicated
      replicas: 3
```

심심하니까 진짜로 해보면

서비스마다 deploy: 옵션을 넣으면 같은 컨테이너를 동일한 설정으로 여러개 복제해서 띄울 수 있습니다.

복제해서 실행하려면 docker compose --compatibility up 이런 명령어 쓰면 됩니다.

---
