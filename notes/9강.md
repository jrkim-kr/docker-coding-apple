# 9. Network 2. 컨테이너간 통신

## 📑 목차

### 📘 핵심 정리 섹션

1. [학습 목표](#학습-목표)
2. [사전 지식](#사전-지식)
3. [1단계: Docker Network 개념 이해](#1단계-docker-network-개념-이해)
   - [왜 Network가 필요한가요?](#왜-network가-필요한가요)
   - [가상 IP 주소란?](#가상-ip-주소란)
4. [2단계: Network 생성하기](#2단계-network-생성하기)
   - [Network 만들기](#network-만들기)
   - [Network 목록 확인](#network-목록-확인)
5. [3단계: 컨테이너를 Network에 연결하기](#3단계-컨테이너를-network에-연결하기)
   - [실행 중인 컨테이너 정리](#실행-중인-컨테이너-정리)
   - [Network에 컨테이너 추가하며 실행](#network에-컨테이너-추가하며-실행)
   - [컨테이너 이름 지정의 중요성](#컨테이너-이름-지정의-중요성)
6. [4단계: Network 설정 확인하기](#4단계-network-설정-확인하기)
   - [Docker Desktop에서 확인](#docker-desktop에서-확인)
   - [가상 IP 주소 확인](#가상-ip-주소-확인)
7. [5단계: 컨테이너 간 통신 테스트](#5단계-컨테이너-간-통신-테스트)
   - [컨테이너 터미널 접속](#컨테이너-터미널-접속)
   - [curl로 통신 테스트](#curl로-통신-테스트)
   - [DNS 자동 변환](#dns-자동-변환)
8. [6단계: Nginx 설정 수정](#6단계-nginx-설정-수정)
   - [설정 파일 업데이트](#설정-파일-업데이트)
   - [재빌드 및 테스트](#재빌드-및-테스트)
   - [포트 매핑 최적화](#포트-매핑-최적화)
9. [7단계: Network 모드 이해하기](#7단계-network-모드-이해하기)
   - [Bridge 모드 (기본)](#bridge-모드-기본)
   - [Host 모드](#host-모드)
   - [보안 고려사항](#보안-고려사항)
10. [핵심 요약](#핵심-요약)
11. [문제 해결 가이드](#문제-해결-가이드)
    - [컨테이너 간 통신이 안 될 때](#컨테이너-간-통신이-안-될-때)
    - [Nginx 설정 변경이 반영 안 될 때](#nginx-설정-변경이-반영-안-될-때)
12. [연습 문제](#연습-문제)
    - [기본 문제](#기본-문제)
    - [중급 문제](#중급-문제)
    - [심화 문제](#심화-문제)

### 📝 강의 스크립트 섹션

13. [강의 스크립트](#강의-스크립트)
14. [네트워크 만들기](#네트워크-만들기)
15. [통신하기](#통신하기)
16. [다시 nginx와 웹서버 연동](#다시-nginx와-웹서버-연동)
17. [bridge모드, host 모드](#bridge모드-host-모드)

---

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Network의 개념과 필요성 이해
- 사용자 정의 Network 생성 및 관리
- 컨테이너를 Network에 연결하여 실행
- 컨테이너 간 통신 테스트 및 검증
- Nginx와 웹서버를 Network로 연동

---

## 📚 사전 지식

- Docker 기본 명령어 (run, exec, ps)
- 이전 강의의 Nginx 설정
- IP 주소와 포트의 개념
- 컨테이너가 독립된 환경임을 이해

---

## 1단계: Docker Network 개념 이해

### 왜 Network가 필요한가요?

이전 강의에서 본 문제를 다시 떠올려봅시다:

```
[Nginx 컨테이너] ← localhost:8080을 찾지만 자기 자신만 확인
    X
[웹서버 컨테이너] ← 여기 8080에 웹서버가 있지만 접근 불가
```

**각 컨테이너는 독립된 가상 컴퓨터**이기 때문에 기본적으로 서로를 볼 수 없습니다.

### 가상 IP 주소란?

Docker Network를 만들어 컨테이너를 넣으면:

```
[mynet1 Network]
├─ [Nginx 컨테이너] → 가상 IP: 172.18.0.2
└─ [웹서버 컨테이너] → 가상 IP: 172.18.0.3
```

- 각 컨테이너에 **가상 IP 주소**가 부여됩니다
- 같은 Network 안의 컨테이너들은 서로의 IP로 통신 가능
- 컨테이너 이름으로도 접근 가능 (DNS 자동 변환)

---

## 2단계: Network 생성하기

### Network 만들기

터미널을 열고 다음 명령어를 입력하세요:

```bash
docker network create mynet1
```

- `mynet1`은 네트워크 이름입니다 (원하는 이름으로 변경 가능)
- 성공하면 긴 ID 문자열이 출력됩니다

### Network 목록 확인

생성된 네트워크를 확인해봅시다:

```bash
docker network ls
```

출력 예시:

```
NETWORK ID     NAME      DRIVER    SCOPE
abcd1234efgh   mynet1    bridge    local
...
```

- `DRIVER`가 `bridge`로 표시되면 정상입니다 (기본 모드)

---

## 3단계: 컨테이너를 Network에 연결하기

### 실행 중인 컨테이너 정리

기존 컨테이너들을 먼저 중지하고 삭제합니다:

```bash
docker stop my-nginx
docker stop my-webserver
docker rm my-nginx
docker rm my-webserver
```

### Network에 컨테이너 추가하며 실행

이제 두 컨테이너를 Network에 포함시켜 실행합니다:

```bash
# Nginx 컨테이너 실행
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1

# 웹서버 컨테이너 실행
docker run -d -p 8080:8080 --network mynet1 --name nodeserver-container nodeserver:1
```

**새로운 옵션 설명:**

- `--network mynet1`: 컨테이너를 mynet1 네트워크에 연결
- `--name nginx-container`: 컨테이너에 이름 부여
- `-d`: 백그라운드 실행
- `-p 80:80`: 포트 매핑 (호스트:컨테이너)

### 컨테이너 이름 지정의 중요성

컨테이너에 이름을 지정하면:

- 관리가 쉬워집니다
- 다른 컨테이너에서 **이름으로 접근 가능**
- 로그 확인이나 디버깅 시 편리

---

## 4단계: Network 설정 확인하기

### Docker Desktop에서 확인

1. Docker Desktop 실행
2. `Containers` 메뉴에서 컨테이너 선택
3. `Inspect` 탭 클릭
4. 아래로 스크롤하여 `Networks` 섹션 확인

### 가상 IP 주소 확인

Inspect에서 다음과 같은 정보를 확인할 수 있습니다:

```json
"Networks": {
  "mynet1": {
    "IPAddress": "172.18.0.2",
    "Gateway": "172.18.0.1",
    ...
  }
}
```

- `IPAddress`: 이 컨테이너의 가상 IP
- 같은 네트워크의 다른 컨테이너는 이 IP로 접근 가능

**터미널로 확인하는 방법:**

```bash
docker inspect nginx-container | grep IPAddress
```

---

## 5단계: 컨테이너 간 통신 테스트

### 컨테이너 터미널 접속

Nginx 컨테이너의 터미널로 들어가봅시다:

```bash
docker exec -it nginx-container /bin/sh
```

또는 Docker Desktop에서:

- 컨테이너 선택 → `Exec` 탭 클릭

프롬프트가 `#` 또는 `$`로 바뀌면 성공!

### curl로 통신 테스트

컨테이너 터미널 안에서 다음을 시도해보세요:

#### 방법 1: IP 주소로 접근

```bash
curl 172.18.0.3:8080
```

(웹서버 컨테이너의 실제 IP로 변경하세요)

#### 방법 2: 컨테이너 이름으로 접근

```bash
curl nodeserver-container:8080
```

#### 방법 3: 네트워크 이름 포함 (더 명확)

```bash
curl nodeserver-container.mynet1:8080
```

**결과:**

- HTML 코드나 응답이 보이면 **통신 성공**!
- 에러가 나면 컨테이너 이름이나 네트워크 설정 재확인

### DNS 자동 변환

컨테이너 이름으로 접근이 가능한 이유:

- Docker는 내부 **DNS 서버**를 자동 실행
- 컨테이너 이름을 IP 주소로 자동 변환
- 마치 인터넷 도메인 이름이 IP로 변환되는 것과 같은 원리

---

## 6단계: Nginx 설정 수정

### 설정 파일 업데이트

이제 Nginx가 웹서버 컨테이너로 요청을 전달하도록 수정합니다.

`myconfig1.conf` 파일을 열고 수정:

```nginx
server {
    listen 80;
    location / {
        proxy_pass http://nodeserver-container:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**변경 사항:**

- `http://localhost:8080` → `http://nodeserver-container:8080`
- IP 주소 대신 컨테이너 이름 사용 (더 유연함)

### 재빌드 및 테스트

1. **이미지 재빌드:**

```bash
docker build -t nginx:1 .
```

2. **기존 컨테이너 중지 및 삭제:**

```bash
docker stop nginx-container
docker rm nginx-container
```

3. **새로 실행:**

```bash
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1
```

4. **브라우저에서 테스트:**
   - `http://localhost:80` 접속
   - 웹서버 페이지가 보이면 **성공**!

### 포트 매핑 최적화

**중요한 인사이트:**

웹서버 컨테이너는 외부(호스트)에서 직접 접근할 필요가 없습니다.

- Nginx만 접근하면 되기 때문
- 따라서 `-p 8080:8080` 옵션을 생략 가능

**최적화된 웹서버 실행:**

```bash
docker run -d --network mynet1 --name nodeserver-container nodeserver:1
```

이렇게 하면:

- ✅ 포트 낭비 방지
- ✅ 보안 강화 (외부 직접 접근 차단)
- ✅ Nginx를 통해서만 접근 가능

---

## 7단계: Network 모드 이해하기

### Bridge 모드 (기본)

```bash
docker network create mynet1
# 자동으로 bridge 모드
```

**특징:**

- 가상 네트워크를 격리된 환경으로 생성
- 컨테이너들이 서로 통신 가능
- 호스트와는 포트 매핑으로 연결
- **권장 모드** (대부분의 경우 이것 사용)

### Host 모드

```bash
docker network create --driver host mynet-host
```

**특징:**

- 컨테이너가 호스트의 네트워크를 직접 사용
- 포트 매핑 불필요 (컨테이너 포트 = 호스트 포트)
- 성능은 조금 더 좋을 수 있음
- **보안상 권장하지 않음**

### 보안 고려사항

**포트는 최소한으로만 열어야 합니다:**

❌ **나쁜 예:**

```bash
# 모든 포트를 열어버림
docker run -p 80:80 -p 8080:8080 -p 3000:3000 ...
```

✅ **좋은 예:**

```bash
# 필요한 포트만 열기
docker run -p 80:80 --network mynet1 ...
```

**이유:**

- 불필요한 포트는 보안 취약점
- 공격자가 침입할 수 있는 경로 제공
- Bridge 모드 + 최소 포트 오픈 = 안전

---

## 🎓 핵심 요약

1. **Docker Network**는 컨테이너들이 서로 통신할 수 있게 해주는 가상 네트워크
2. **가상 IP 주소**가 각 컨테이너에 자동 부여됨
3. **컨테이너 이름**으로 다른 컨테이너에 접근 가능 (DNS 자동 변환)
4. **Bridge 모드**가 기본이며 대부분의 경우 이것만 사용
5. **외부 접근이 필요 없는 컨테이너**는 포트 매핑 생략 가능
6. **보안**: 필요한 포트만 최소한으로 열기

---

## 🔧 문제 해결 가이드

### 컨테이너 간 통신이 안 될 때

1. **같은 네트워크에 있는지 확인:**

```bash
docker inspect nginx-container | grep NetworkID
docker inspect nodeserver-container | grep NetworkID
```

두 ID가 같아야 합니다.

2. **컨테이너 이름 확인:**

```bash
docker ps
```

실제 컨테이너 이름과 설정 파일의 이름이 일치하는지 확인

3. **웹서버가 실제로 실행 중인지 확인:**

```bash
docker logs nodeserver-container
```

4. **방화벽 확인:**

- 호스트의 방화벽이 Docker 통신을 차단하지 않는지 확인

### Nginx 설정 변경이 반영 안 될 때

```bash
# 1. 컨테이너 중지 및 삭제
docker stop nginx-container
docker rm nginx-container

# 2. 이미지 재빌드
docker build -t nginx:1 .

# 3. 새로 실행
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1
```

---

## 💡 연습 문제

### 기본 문제

1. `testnet`이라는 이름의 네트워크를 생성해보세요
2. 생성한 네트워크의 목록을 확인하는 명령어를 실행해보세요
3. 컨테이너 하나를 testnet에 연결하여 실행해보세요

### 중급 문제

4. 실행 중인 컨테이너의 가상 IP 주소를 터미널 명령어로 확인해보세요
5. 한 컨테이너에서 다른 컨테이너로 ping 또는 curl을 시도해보세요
6. 웹서버 컨테이너를 `-p` 옵션 없이 실행하고, Nginx를 통해서만 접근 가능한지 확인해보세요

### 심화 문제

7. 3개의 컨테이너(Nginx 1개, 웹서버 2개)를 같은 네트워크에 연결하고, Nginx가 두 웹서버로 요청을 번갈아 보내도록 설정해보세요 (로드 밸런싱)
8. 네트워크를 삭제하는 명령어는 무엇일까요? (`docker network rm`)
9. 한 컨테이너를 여러 네트워크에 동시에 연결할 수 있을까요? 시도해보세요

---

# 강의 스크립트

컨테이너들은 각각의 독립적인 컴퓨터기 때문에 원래 서로 만나고 그럴 수가 없습니다.

근데 네트워크를 만들어서 그 안에 집어넣으면 서로 만날 수 있습니다.

왜냐면 네트워크에 컨테이너를 넣으면 컨테이너마다 **가상 IP 주소**를 부여해줍니다.

그래서 컨테이너가 다른 컨테이너로 접속하고 요청날리고 그러고 싶으면 가상 IP 주소를 사용하면 되는데

엄마가 남의 말 믿지 말랬으니까 직접 네트워크를 하나 만들어봅시다.

> 네트워크 만들기

```lua
docker network create 네트워크이름작명
```

터미널에서 이런걸 입력하면 네트워크를 하나 가상으로 만들 수 있습니다.

저는 mynet1 이라는 네트워크를 만들어봤음

```
docker network ls
```

만들어둔 네트워크 목록 조회도 가능합니다.

컨테이너를 네트워크에 넣으려면

- 이미 실행중인 컨테이너를 네트워크에 집어넣을 수도 있고
- 아니면 애초에 컨테이너 실행할 때 네트워크에 넣으라고 코드짤 수도 있는데

후자로 해봅시다.

실행중인 컨테이너 끄고 터미널 명령어를 이용해서 컨테이너를 띄워봅시다.

```
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1
docker run -d -p 8080:8080 --network mynet1 --name nodeserver-container nodeserver:1
```

컨테이너 실행할 때 "네트워크 안에 담아주세요" 하고 싶으면

- **-network 네트워크이름** 이용하면 되겠습니다.
- **-name 컨테이너이름** 사용하면 컨테이너 이름도 맘대로 정할 수 있습니다.

컨테이너 이름도 이번 기회에 한번 지어봅시다. 그럼 컨테이너가 좋아하지 않을까요.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EC%BA%A1%EC%B2%9845.png)

▲ Docker desktop에서 컨테이너 상세내용을 살펴볼 수 있는데

Inspect 메뉴 들어가보면 지금 컨테이너가 어떤 네트워크에 속해있는 지도 검사해볼 수 있습니다.

사진 보면 mynet1 이라는 네트워크에 속해있고 가상 IP주소도 172.18.0.2가 부여되었군요.

같은 네트워크 안에 있는 컨테이너들은 172.18.0.2로 이 컨테이너를 찾을 수 있습니다.

> 통신하기

컨테이너끼리 통신이 진짜 되나 확인하려면

하나의 컨테이너로 들어가서 거기다가 다른 컨테이너를 불러보면 됩니다.

```python
docker exec -it 컨테이너이름 /bin/sh
```

터미널에서 이런거 입력하면 **그 컨테이너의 터미널로** 들어갈 수 있습니다.

혹은 Docker desktop에서 Container - Exec 메뉴 들어가면 됩니다.

그래서 저는 nginx 컨테이너 터미널로 들어가봤습니다.

```
curl 웹서버컨테이너IP
```

nginx 컨테이너 터미널에서 위처럼 입력해봅시다.

curl이 뭐냐면 그냥 특정 도메인이나 IP 주소로 접속할 때 쓰는 명령어입니다.

그러면 뭔가 뜨지 않습니까? 그러면 통신 된다는 소리입니다.

실은 IP주소 말고 **curl 컨테이너 이름**을 입력해도 아마 잘될 겁니다.

왜냐면 컨테이너 이름을 입력하면 그걸 자동으로 IP주소로 바꿔주는

DNS라는 프로그램을 내부적으로 실행하고 있기 때문에 그런 것임

더 정확히 하려면 **curl 컨테이너이름.네트워크이름** 이렇게 써도 됩니다.

> 다시 nginx와 웹서버 연동

아무튼 다시 돌아가서

nginx에서 웹서버로 통신이 되도록 고쳐봅시다.

이제 nginx 들어오면 웹서버 컨테이너로 보내라고 코드짜려면

```perl
(myconfig1.conf)

server {
        listen 80;
        location / {
            proxy_pass http://웹서버컨테이너IP:8080;
            (생략)
        }
}
```

이제 이렇게 바꾸면 되겠네요.

혹은 IP 대신 웹서버 컨테이너의 이름만 넣어도 됩니다.

진짜 잘 되는지 이미지 빌드하고 실행도 해보고 nginx주소로 접속해봅시다.

그럼 웹서버가 잘 뜨면 성공입니다.

(참고) 웹서버 컨테이너의 경우에는 nginx에서 접속하면 끝이라

내 컴퓨터인 호스트와 포트 연결작업이 필요없습니다.

그래서 웹서버 컨테이너 띄울 때는 -p 옵션은 빼도 되지 않을까요.

> bridge모드, host 모드

기본적으로 network를 하나 만들면 bridge 모드로 만들어줍니다.

그거 말고 host 모드로도 네트워크를 만들 수 있는데

그러면 가상컴퓨터들이 내 실제 컴퓨터에서 돌아가는 프로그램처럼 네트워크 자원을 마구 사용할 수 있습니다.

근데 그 정도의 권한을 가져야하는 프로그램은 거의 없기 때문에 별로 쓸 일은 없고

그냥 기본적으로 생성되는 bridge모드로 네트워크를 만들어서 쓰면 되겠습니다.

왜냐면 대충 포트를 마구 열어버리거나 그러면 누가 침입할 수 있는 기회를 마련해주는 것이므로

포트 오픈은 최소화하는게 좋습니다.

오늘의 결론은

1. nginx 같은 리버스 프록시 쓰면 웹서버 운영할 때 도움됨

2. 네트워크 안에 컨테이너 넣으면 서로 쉽게 통신가능
