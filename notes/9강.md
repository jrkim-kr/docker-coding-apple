# 9. Network 2. 컨테이너간 통신

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Network의 개념과 필요성 이해
- 사용자 정의 Network 생성 및 관리
- 컨테이너를 Network에 연결하여 실행
- 컨테이너 간 통신 테스트 및 검증
- Nginx와 웹서버를 Network로 연동

---

## 📚 사전 지식

- Docker 기본 명령어 (run, exec, ps)
- 이전 강의의 Nginx 설정
- IP 주소와 포트의 개념
- 컨테이너가 독립된 환경임을 이해

---

## 1단계: Docker Network 개념 이해

### 왜 Network가 필요한가요?

이전 강의에서 본 문제를 다시 떠올려봅시다:

```
[Nginx 컨테이너] ← localhost:8080을 찾지만 자기 자신만 확인
    X
[웹서버 컨테이너] ← 여기 8080에 웹서버가 있지만 접근 불가
```

**각 컨테이너는 독립된 가상 컴퓨터**이기 때문에 기본적으로 서로를 볼 수 없습니다.

### 가상 IP 주소란?

Docker Network를 만들어 컨테이너를 넣으면:

```
[mynet1 Network]
├─ [Nginx 컨테이너] → 가상 IP: 172.18.0.2
└─ [웹서버 컨테이너] → 가상 IP: 172.18.0.3
```

- 각 컨테이너에 **가상 IP 주소**가 부여됩니다
- 같은 Network 안의 컨테이너들은 서로의 IP로 통신 가능
- 컨테이너 이름으로도 접근 가능 (DNS 자동 변환)

---

## 2단계: Network 생성하기

### Network 만들기

터미널을 열고 다음 명령어를 입력하세요:

```bash
docker network create mynet1
```

- `mynet1`은 네트워크 이름입니다 (원하는 이름으로 변경 가능)
- 성공하면 긴 ID 문자열이 출력됩니다

### Network 목록 확인

생성된 네트워크를 확인해봅시다:

```bash
docker network ls
```

출력 예시:

```
NETWORK ID     NAME      DRIVER    SCOPE
abcd1234efgh   mynet1    bridge    local
...
```

- `DRIVER`가 `bridge`로 표시되면 정상입니다 (기본 모드)

---

## 3단계: 컨테이너를 Network에 연결하기

### 실행 중인 컨테이너 정리

기존 컨테이너들을 먼저 중지하고 삭제합니다:

```bash
docker stop my-nginx
docker stop my-webserver
docker rm my-nginx
docker rm my-webserver
```

### Network에 컨테이너 추가하며 실행

이제 두 컨테이너를 Network에 포함시켜 실행합니다:

```bash
# Nginx 컨테이너 실행
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1

# 웹서버 컨테이너 실행
docker run -d -p 8080:8080 --network mynet1 --name nodeserver-container nodeserver:1
```

**새로운 옵션 설명:**

- `--network mynet1`: 컨테이너를 mynet1 네트워크에 연결
- `--name nginx-container`: 컨테이너에 이름 부여
- `-d`: 백그라운드 실행
- `-p 80:80`: 포트 매핑 (호스트:컨테이너)

### 컨테이너 이름 지정의 중요성

컨테이너에 이름을 지정하면:

- 관리가 쉬워집니다
- 다른 컨테이너에서 **이름으로 접근 가능**
- 로그 확인이나 디버깅 시 편리

---

## 4단계: Network 설정 확인하기

### Docker Desktop에서 확인

1. Docker Desktop 실행
2. `Containers` 메뉴에서 컨테이너 선택
3. `Inspect` 탭 클릭
4. 아래로 스크롤하여 `Networks` 섹션 확인

### 가상 IP 주소 확인

Inspect에서 다음과 같은 정보를 확인할 수 있습니다:

```json
"Networks": {
  "mynet1": {
    "IPAddress": "172.18.0.2",
    "Gateway": "172.18.0.1",
    ...
  }
}
```

- `IPAddress`: 이 컨테이너의 가상 IP
- 같은 네트워크의 다른 컨테이너는 이 IP로 접근 가능

**터미널로 확인하는 방법:**

```bash
docker inspect nginx-container | grep IPAddress
```

---

## 5단계: 컨테이너 간 통신 테스트

### 컨테이너 터미널 접속

Nginx 컨테이너의 터미널로 들어가봅시다:

```bash
docker exec -it nginx-container /bin/sh
```

또는 Docker Desktop에서:

- 컨테이너 선택 → `Exec` 탭 클릭

프롬프트가 `#` 또는 `$`로 바뀌면 성공!

### curl로 통신 테스트

컨테이너 터미널 안에서 다음을 시도해보세요:

#### 방법 1: IP 주소로 접근

```bash
curl 172.18.0.3:8080
```

(웹서버 컨테이너의 실제 IP로 변경하세요)

#### 방법 2: 컨테이너 이름으로 접근

```bash
curl nodeserver-container:8080
```

#### 방법 3: 네트워크 이름 포함 (더 명확)

```bash
curl nodeserver-container.mynet1:8080
```

**결과:**

- HTML 코드나 응답이 보이면 **통신 성공**!
- 에러가 나면 컨테이너 이름이나 네트워크 설정 재확인

### DNS 자동 변환

컨테이너 이름으로 접근이 가능한 이유:

- Docker는 내부 **DNS 서버**를 자동 실행
- 컨테이너 이름을 IP 주소로 자동 변환
- 마치 인터넷 도메인 이름이 IP로 변환되는 것과 같은 원리

---

## 6단계: Nginx 설정 수정

### 설정 파일 업데이트

이제 Nginx가 웹서버 컨테이너로 요청을 전달하도록 수정합니다.

`myconfig1.conf` 파일을 열고 수정:

```nginx
server {
    listen 80;
    location / {
        proxy_pass http://nodeserver-container:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**변경 사항:**

- `http://localhost:8080` → `http://nodeserver-container:8080`
- IP 주소 대신 컨테이너 이름 사용 (더 유연함)

### 재빌드 및 테스트

1. **이미지 재빌드:**

```bash
docker build -t nginx:1 .
```

2. **기존 컨테이너 중지 및 삭제:**

```bash
docker stop nginx-container
docker rm nginx-container
```

3. **새로 실행:**

```bash
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1
```

4. **브라우저에서 테스트:**
   - `http://localhost:80` 접속
   - 웹서버 페이지가 보이면 **성공**!

### 포트 매핑 최적화

**중요한 인사이트:**

웹서버 컨테이너는 외부(호스트)에서 직접 접근할 필요가 없습니다.

- Nginx만 접근하면 되기 때문
- 따라서 `-p 8080:8080` 옵션을 생략 가능

**최적화된 웹서버 실행:**

```bash
docker run -d --network mynet1 --name nodeserver-container nodeserver:1
```

이렇게 하면:

- ✅ 포트 낭비 방지
- ✅ 보안 강화 (외부 직접 접근 차단)
- ✅ Nginx를 통해서만 접근 가능

---

## 7단계: Network 모드 이해하기

### Bridge 모드 (기본)

```bash
docker network create mynet1
# 자동으로 bridge 모드
```

**특징:**

- 가상 네트워크를 격리된 환경으로 생성
- 컨테이너들이 서로 통신 가능
- 호스트와는 포트 매핑으로 연결
- **권장 모드** (대부분의 경우 이것 사용)

### Host 모드

```bash
docker network create --driver host mynet-host
```

**특징:**

- 컨테이너가 호스트의 네트워크를 직접 사용
- 포트 매핑 불필요 (컨테이너 포트 = 호스트 포트)
- 성능은 조금 더 좋을 수 있음
- **보안상 권장하지 않음**

### 보안 고려사항

**포트는 최소한으로만 열어야 합니다:**

❌ **나쁜 예:**

```bash
# 모든 포트를 열어버림
docker run -p 80:80 -p 8080:8080 -p 3000:3000 ...
```

✅ **좋은 예:**

```bash
# 필요한 포트만 열기
docker run -p 80:80 --network mynet1 ...
```

**이유:**

- 불필요한 포트는 보안 취약점
- 공격자가 침입할 수 있는 경로 제공
- Bridge 모드 + 최소 포트 오픈 = 안전

---

## 🎓 핵심 요약

1. **Docker Network**는 컨테이너들이 서로 통신할 수 있게 해주는 가상 네트워크
2. **가상 IP 주소**가 각 컨테이너에 자동 부여됨
3. **컨테이너 이름**으로 다른 컨테이너에 접근 가능 (DNS 자동 변환)
4. **Bridge 모드**가 기본이며 대부분의 경우 이것만 사용
5. **외부 접근이 필요 없는 컨테이너**는 포트 매핑 생략 가능
6. **보안**: 필요한 포트만 최소한으로 열기

---

## 🔧 문제 해결 가이드

### 컨테이너 간 통신이 안 될 때

1. **같은 네트워크에 있는지 확인:**

```bash
docker inspect nginx-container | grep NetworkID
docker inspect nodeserver-container | grep NetworkID
```

두 ID가 같아야 합니다.

2. **컨테이너 이름 확인:**

```bash
docker ps
```

실제 컨테이너 이름과 설정 파일의 이름이 일치하는지 확인

3. **웹서버가 실제로 실행 중인지 확인:**

```bash
docker logs nodeserver-container
```

4. **방화벽 확인:**

- 호스트의 방화벽이 Docker 통신을 차단하지 않는지 확인

### Nginx 설정 변경이 반영 안 될 때

```bash
# 1. 컨테이너 중지 및 삭제
docker stop nginx-container
docker rm nginx-container

# 2. 이미지 재빌드
docker build -t nginx:1 .

# 3. 새로 실행
docker run -d -p 80:80 --network mynet1 --name nginx-container nginx:1
```

---

## 💡 연습 문제

### 기본 문제

1. `testnet`이라는 이름의 네트워크를 생성해보세요
2. 생성한 네트워크의 목록을 확인하는 명령어를 실행해보세요
3. 컨테이너 하나를 testnet에 연결하여 실행해보세요

### 중급 문제

4. 실행 중인 컨테이너의 가상 IP 주소를 터미널 명령어로 확인해보세요
5. 한 컨테이너에서 다른 컨테이너로 ping 또는 curl을 시도해보세요
6. 웹서버 컨테이너를 `-p` 옵션 없이 실행하고, Nginx를 통해서만 접근 가능한지 확인해보세요

### 심화 문제

7. 3개의 컨테이너(Nginx 1개, 웹서버 2개)를 같은 네트워크에 연결하고, Nginx가 두 웹서버로 요청을 번갈아 보내도록 설정해보세요 (로드 밸런싱)
8. 네트워크를 삭제하는 명령어는 무엇일까요? (`docker network rm`)
9. 한 컨테이너를 여러 네트워크에 동시에 연결할 수 있을까요? 시도해보세요

---
