# 15. Orchestration 2. 태스크 정의, health check

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- AWS ECS의 핵심 개념 이해 (클러스터, 서비스, 태스크)
- Fargate를 이용한 서버리스 컨테이너 배포
- 태스크 정의 작성 및 컨테이너 설정
- Health Check를 통한 컨테이너 모니터링

---

## 📚 사전 준비

### 필수 사항

- ✅ Docker Hub에 업로드된 이미지 2개 (nginx, 웹서버)
- ✅ AWS 계정 생성 및 카드 등록
- ✅ Docker 기본 개념 이해

### 확인 사항

```bash
# Docker Hub에 이미지가 올라가 있는지 확인
# 형식: docker.io/당신의아이디/리포지토리명:태그

```

---

## 1단계: AWS ECS란?

### ECS가 뭔가요?

**Elastic Container Service**의 약자로, AWS에서 제공하는 컨테이너 오케스트레이션 서비스입니다.

```
[로컬 Docker] → [Docker Hub] → [AWS ECS] → 인터넷에 배포!

```

**쉽게 말하면:**

- 내 컴퓨터에서 만든 Docker 이미지를
- AWS 클라우드 서버에서 실행시키는 서비스

### 핵심 개념 3가지

```
┌─────────────────────────────────────┐
│         클러스터 (Cluster)           │  ← 프로젝트/그룹
│  ┌────────────────────────────────┐ │
│  │      서비스 (Service)          │  ← 컨테이너 관리자
│  │  ┌──────────────────────────┐ │ │
│  │  │   태스크 (Task)          │  ← 실제 컨테이너
│  │  │  [nginx] [웹서버]        │ │ │
│  │  └──────────────────────────┘ │ │
│  └────────────────────────────────┘ │
└─────────────────────────────────────┘

```

1. **클러스터**: 컴퓨터 자원을 묶어놓은 그룹
2. **서비스**: 태스크를 안정적으로 관리 (자동 재시작, 무중단 배포)
3. **태스크**: 실제로 실행되는 컨테이너들의 묶음

---

## 2단계: EC2 vs Fargate 선택

AWS ECS에서 컨테이너를 실행하는 방법은 2가지입니다.

### EC2 방식

```
[EC2 인스턴스] ← 컴퓨터를 미리 빌림
    ↓
[컨테이너 실행]

```

**장점:**

- 비용이 저렴 (20% 정도)
- 세밀한 제어 가능

**단점:**

- 서버 관리 필요
- 미리 점유해야 함

**예시:**

- t2.micro: CPU 1개, 메모리 1GB (1년 무료)
- t3.micro: CPU 2개, 메모리 1GB (1년 무료)

### Fargate 방식 (권장)

```
[Fargate] ← 필요할 때만 자원 사용
    ↓
[컨테이너 실행]

```

**장점:**

- ✅ 서버 관리 불필요 (서버리스)
- ✅ 필요한 만큼만 사용
- ✅ 자동 확장/축소

**단점:**

- 비용이 20% 더 비쌈

**💡 추천 사항:**

- 처음 시작하는 경우 → **Fargate** 선택
- 간단한 테스트 시 요금은 몇백원 수준

---

## 3단계: 클러스터 생성

### AWS 콘솔 접속

1. **AWS 콘솔 로그인**
2. **우측 상단에서 지역 선택** → 서울 (ap-northeast-2)
3. **검색창에 "ECS" 입력** → Elastic Container Service 선택

### 클러스터 생성하기

```
ECS 대시보드
    ↓
[클러스터] 메뉴
    ↓
[클러스터 생성] 버튼 클릭

```

**설정 항목:**

| 항목          | 값               | 설명               |
| ------------- | ---------------- | ------------------ |
| 클러스터 이름 | my-first-cluster | 알아보기 쉬운 이름 |
| 인프라        | AWS Fargate      | 서버리스 선택      |

**⚠️ 주의사항:**

- EC2를 선택하면 인스턴스 타입, 수량 등을 추가로 설정해야 함
- CPU 아키텍처 확인 필요 (대부분 AMD64/x86-64)

**완료:**

```bash
✓ 클러스터 생성 완료!
→ 다음: 태스크 정의 만들기

```

---

## 4단계: 태스크 정의 만들기

### 태스크 정의가 뭔가요?

**Docker Compose와 같은 역할**을 하는 설정 파일입니다.

```yaml
# Docker Compose 파일 (참고)
services:
  nginx:
    image: my-nginx:1
    ports:
      - "80:80"
  web:
    image: my-web:1
    ports:
      - "8080:8080"
```

```json
// AWS ECS 태스크 정의 (JSON 형식)
{
  "family": "my-task",
  "containerDefinitions": [
    {
      "name": "nginx",
      "image": "docker.io/myid/nginx:1",
      "portMappings": [{ "containerPort": 80 }]
    },
    {
      "name": "web",
      "image": "docker.io/myid/web:1",
      "portMappings": [{ "containerPort": 8080 }]
    }
  ]
}
```

**핵심:**

- 어떤 이미지를 사용할지
- 어떤 포트를 열지
- CPU/메모리를 얼마나 할당할지

### 태스크 정의 생성 시작

```
ECS 대시보드
    ↓
[태스크 정의] 메뉴
    ↓
[새 태스크 정의 생성] 버튼

```

### 인프라 설정

**1. 기본 설정**

| 항목      | 권장값       | 설명                    |
| --------- | ------------ | ----------------------- |
| 시작 유형 | AWS Fargate  | 서버리스                |
| 운영 체제 | Linux/X86_64 | 대부분의 경우           |
| CPU       | 1 vCPU       | 0.25, 0.5, 1, 2 중 선택 |
| 메모리    | 2 GB         | CPU에 따라 옵션 다름    |

**💡 CPU/메모리 조합 예시:**

```
CPU 0.25 → 메모리 0.5GB ~ 2GB
CPU 0.5  → 메모리 1GB ~ 4GB
CPU 1    → 메모리 2GB ~ 8GB
CPU 2    → 메모리 4GB ~ 16GB

```

**⚠️ 주의:**

- 태스크에 할당한 CPU/메모리를 컨테이너들이 **나눠서 사용**
- 웹서버 + Nginx → 최소 1 vCPU, 2GB 권장

---

### 컨테이너 설정 - 웹서버

**컨테이너 1: 웹서버 추가**

```
[컨테이너 추가] 버튼 클릭

```

**기본 정보:**

| 항목          | 값 예시                    | 설명               |
| ------------- | -------------------------- | ------------------ |
| 컨테이너 이름 | my-webserver               | 식별하기 쉬운 이름 |
| 이미지 URI    | docker.io/myid/webserver:1 | Docker Hub 경로    |

**이미지 URI 형식:**

```
docker.io/[Docker Hub ID]/[리포지토리명]:[태그]

예시:
docker.io/john123/nodejs-server:latest
docker.io/john123/nodejs-server:v1.0

```

**포트 매핑:**

| 이름           | 컨테이너 포트 | 프로토콜 |
| -------------- | ------------- | -------- |
| webserver-port | 8080          | TCP      |

**💡 포트 매핑 팁:**

- 웹서버는 Nginx를 통해서만 접근할 예정
- 포트 매핑을 비워둬도 OK (내부 통신만 사용)

**리소스 할당:**

```
CPU: 0.5 단위 (전체 1 vCPU 중)
메모리:
  - Soft limit: 1024 MB (최소 보장)
  - Hard limit: 비워둠 (무제한)

```

**메모리 제한 이해하기:**

```
Soft Limit (1024 MB)
    ↓
컨테이너가 기본적으로 사용할 메모리
    ↓
필요시 더 사용 가능
    ↓
Hard Limit 도달 시 → 컨테이너 강제 종료

```

**Node.js 서버의 경우:**

- 최소 1GB 메모리 권장
- Soft limit: 1024 MB 설정

---

### 컨테이너 설정 - Nginx

**컨테이너 2: Nginx 추가**

```
[컨테이너 추가] 버튼 클릭

```

**기본 정보:**

| 항목          | 값 예시                |
| ------------- | ---------------------- |
| 컨테이너 이름 | my-nginx               |
| 이미지 URI    | docker.io/myid/nginx:1 |

**포트 매핑:**

| 이름       | 컨테이너 포트 | 프로토콜 |
| ---------- | ------------- | -------- |
| nginx-port | 80            | TCP      |

**⚠️ 중요:**

- Nginx는 외부에서 접근해야 하므로 **포트 매핑 필수**

**리소스 할당:**

```
CPU: 0.5 단위
메모리 Soft limit: 512 MB

```

---

## 5단계: Health Check 설정

### Health Check가 뭔가요?

컨테이너가 **정상적으로 작동하는지 자동으로 확인**하는 기능입니다.

```
컨테이너 실행
    ↓
매 X초마다 확인
    ↓
정상? → 계속 실행
비정상? → 재시작 또는 알림

```

**실제 동작:**

```bash
# Health Check가 자동으로 실행하는 명령어
curl -f http://localhost:8080 || exit 1

```

**왜 필요한가요?**

- ✅ 자동 모니터링
- ✅ 문제 발생 시 자동 재시작
- ✅ 배포 시 안전성 확보

### curl 사용하기

**웹서버 컨테이너 Health Check:**

```
명령: CMD-SHELL,curl -f http://localhost:8080 || exit 1
간격: 30초
제한 시간: 5초
재시도: 3회
시작 기간: 60초

```

**명령어 분석:**

```bash
CMD-SHELL              # bash 같은 기본 셸 사용
curl -f                # HTTP 요청 보내기 (-f는 실패시 에러 반환)
http://localhost:8080  # 확인할 주소
||                     # 또는 (실패하면)
exit 1                 # 종료 코드 1 (실패 신호)

```

**설정값 이해:**

| 설정      | 의미                    | 권장값 |
| --------- | ----------------------- | ------ |
| 간격      | 체크 주기               | 30초   |
| 제한 시간 | 응답 대기 시간          | 5초    |
| 재시도    | 연속 실패 허용          | 3회    |
| 시작 기간 | 처음 체크 시작까지 여유 | 60초   |

**Nginx 컨테이너 Health Check:**

```
명령: CMD-SHELL,curl -f http://localhost:80 || exit 1
간격: 30초
제한 시간: 5초
재시도: 3회
시작 기간: 60초

```

### curl이 없을 때

**문제 상황:**

```bash
# 어떤 이미지는 curl이 설치되어 있지 않음
node:20-slim  # curl 없음
alpine        # curl 없음

```

**해결 방법 1: wget 사용**

```bash
CMD-SHELL,wget --spider http://localhost:8080 || exit 1

```

**해결 방법 2: bash TCP 기능 사용 (추천)**

```bash
CMD-SHELL,timeout 10s bash -c ': > /dev/tcp/localhost/8080' || exit 1

```

**명령어 분석:**

```bash
timeout 10s           # 10초 제한
bash -c               # bash 명령어 실행
': > /dev/tcp/...'    # TCP 연결 시도

```

**bash TCP 사용법 이해:**

```bash
/dev/tcp/localhost/8080  # localhost:8080에 TCP 연결

: >                      # 빈 값을 전송
                         # (디렉터리 열기 방지)

```

**⚠️ 주의사항:**

- 이미지에 bash가 있어야 함
- sh만 있는 경우는 사용 불가

**해결 방법 3: Dockerfile에 curl 설치**

```docker
FROM node:20-slim

# curl 설치
RUN apt-get update && apt-get install -y curl

# 나머지 설정...

```

---

## 환경 변수 설정 (선택사항)

**필요한 경우:**

```
환경 변수 추가
    ↓
키: NODE_ENV
값: production

키: PORT
값: 8080

```

---

## 로깅 설정

**권장 설정:**

```
✓ awslogs 사용
로그 그룹: /ecs/my-task
로그 스트림 접두사: ecs

```

**왜 필요한가요?**

- 에러 발생 시 로그 확인 가능
- CloudWatch에서 실시간 모니터링

---

## 🎓 핵심 요약

### 전체 흐름

```
1. AWS 가입 및 리전 선택
    ↓
2. 클러스터 생성 (Fargate)
    ↓
3. 태스크 정의 작성
   - 인프라 설정 (CPU/메모리)
   - 컨테이너 추가 (웹서버, Nginx)
   - Health Check 설정
    ↓
4. 태스크 정의 생성 완료

```

### 핵심 포인트

| 개념        | 설명               | 비유        |
| ----------- | ------------------ | ----------- |
| 클러스터    | 컴퓨터 자원 그룹   | 아파트 단지 |
| 서비스      | 태스크 관리자      | 관리사무소  |
| 태스크      | 실행 중인 컨테이너 | 각 집       |
| 태스크 정의 | 설정 파일          | 설계도      |

### 리소스 권장 설정

```
태스크 전체: CPU 1, 메모리 2GB
    ↓
웹서버: CPU 0.5, 메모리 1GB
Nginx:  CPU 0.5, 메모리 512MB

```

### Health Check 핵심

```bash
# curl이 있는 경우
curl -f http://localhost:8080 || exit 1

# bash만 있는 경우
timeout 10s bash -c ': > /dev/tcp/localhost/8080' || exit 1

```

---

## 🔍 다음 단계

다음 튜토리얼에서는:

1. **서비스 생성하기**
   - 태스크 정의를 기반으로 서비스 만들기
   - 로드 밸런서 설정
2. **네트워크 설정**
   - VPC와 서브넷 이해
   - 보안 그룹 설정
3. **실제 배포**
   - 태스크 실행
   - 외부 접속 확인
4. **모니터링 및 관리**
   - CloudWatch 로그 확인
   - 자동 스케일링 설정

---

## 🔧 트러블슈팅

### 문제 1: 이미지 URI 오류

**증상:**

```
Error: Unable to pull image

```

**해결:**

```bash
# Docker Hub 이미지 확인
docker.io/[정확한ID]/[정확한리포지토리명]:[존재하는태그]

# 예시
docker.io/john123/myapp:latest  ✓
docker.io/john123/myapp:v1      ✓
docker.io/John123/myapp:latest  ✗ (대소문자 구분)

```

### 문제 2: CPU 아키텍처 불일치

**증상:**

```
exec format error

```

**해결:**

```bash
# 이미지 빌드 시 아키텍처 지정
docker build --platform linux/amd64 -t myapp:1 .

# ECS에서 동일한 아키텍처 선택
운영 체제: Linux/X86_64

```

### 문제 3: Health Check 실패

**증상:**

```
Container unhealthy

```

**해결 순서:**

1. 컨테이너에 직접 접속해서 curl 테스트
2. curl이 없으면 bash TCP 방식 사용
3. 시작 기간을 60초로 늘림 (앱 시작 시간 고려)

```bash
# 수동 테스트
docker exec -it [컨테이너ID] bash
curl localhost:8080

```

### 문제 4: 메모리 부족

**증상:**

```
OutOfMemoryError

```

**해결:**

```
태스크 메모리 증가
1 vCPU, 2GB → 1 vCPU, 4GB

또는

컨테이너별 메모리 재분배
웹서버: 1GB → 1.5GB
Nginx: 512MB → 512MB

```

---

## 💡 실전 팁

### 1. 비용 관리

```
테스트 후 바로 삭제하기
    ↓
서비스 중지
    ↓
태스크 정의 비활성화
    ↓
클러스터 삭제

```

### 2. 이미지 최적화

```
- node:20-slim 같은 slim 이미지 사용
- 멀티 스테이지 빌드 활용
- 불필요한 파일 제거

```

### 3. 로그 활용

```
CloudWatch Logs
    ↓
실시간 모니터링
    ↓
에러 패턴 분석
    ↓
알람 설정

```

---

## 📚 참고 자료

- [AWS ECS 공식 문서](https://docs.aws.amazon.com/ecs/)
- [Fargate 요금 계산기](https://aws.amazon.com/fargate/pricing/)
- [Docker Hub](https://hub.docker.com/)

---
