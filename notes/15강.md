# 15. Orchestration 2. 태스크 정의, health check

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- AWS ECS의 핵심 개념 이해 (클러스터, 서비스, 태스크)
- Fargate를 이용한 서버리스 컨테이너 배포
- 태스크 정의 작성 및 컨테이너 설정
- Health Check를 통한 컨테이너 모니터링

---

## 📚 사전 준비

### 필수 사항

- ✅ Docker Hub에 업로드된 이미지 2개 (nginx, 웹서버)
- ✅ AWS 계정 생성 및 카드 등록
- ✅ Docker 기본 개념 이해

### 확인 사항

```bash
# Docker Hub에 이미지가 올라가 있는지 확인
# 형식: docker.io/당신의아이디/리포지토리명:태그

```

---

## 1단계: AWS ECS란?

### ECS가 뭔가요?

**Elastic Container Service**의 약자로, AWS에서 제공하는 컨테이너 오케스트레이션 서비스입니다.

```
[로컬 Docker] → [Docker Hub] → [AWS ECS] → 인터넷에 배포!

```

**쉽게 말하면:**

- 내 컴퓨터에서 만든 Docker 이미지를
- AWS 클라우드 서버에서 실행시키는 서비스

### 핵심 개념 3가지

```
┌─────────────────────────────────────┐
│         클러스터 (Cluster)           │  ← 프로젝트/그룹
│  ┌────────────────────────────────┐ │
│  │      서비스 (Service)          │  ← 컨테이너 관리자
│  │  ┌──────────────────────────┐ │ │
│  │  │   태스크 (Task)          │  ← 실제 컨테이너
│  │  │  [nginx] [웹서버]        │ │ │
│  │  └──────────────────────────┘ │ │
│  └────────────────────────────────┘ │
└─────────────────────────────────────┘

```

1. **클러스터**: 컴퓨터 자원을 묶어놓은 그룹
2. **서비스**: 태스크를 안정적으로 관리 (자동 재시작, 무중단 배포)
3. **태스크**: 실제로 실행되는 컨테이너들의 묶음

---

## 2단계: EC2 vs Fargate 선택

AWS ECS에서 컨테이너를 실행하는 방법은 2가지입니다.

### EC2 방식

```
[EC2 인스턴스] ← 컴퓨터를 미리 빌림
    ↓
[컨테이너 실행]

```

**장점:**

- 비용이 저렴 (20% 정도)
- 세밀한 제어 가능

**단점:**

- 서버 관리 필요
- 미리 점유해야 함

**예시:**

- t2.micro: CPU 1개, 메모리 1GB (1년 무료)
- t3.micro: CPU 2개, 메모리 1GB (1년 무료)

### Fargate 방식 (권장)

```
[Fargate] ← 필요할 때만 자원 사용
    ↓
[컨테이너 실행]

```

**장점:**

- ✅ 서버 관리 불필요 (서버리스)
- ✅ 필요한 만큼만 사용
- ✅ 자동 확장/축소

**단점:**

- 비용이 20% 더 비쌈

**💡 추천 사항:**

- 처음 시작하는 경우 → **Fargate** 선택
- 간단한 테스트 시 요금은 몇백원 수준

---

## 3단계: 클러스터 생성

### AWS 콘솔 접속

1. **AWS 콘솔 로그인**
2. **우측 상단에서 지역 선택** → 서울 (ap-northeast-2)
3. **검색창에 "ECS" 입력** → Elastic Container Service 선택

### 클러스터 생성하기

```
ECS 대시보드
    ↓
[클러스터] 메뉴
    ↓
[클러스터 생성] 버튼 클릭

```

**설정 항목:**

| 항목          | 값               | 설명               |
| ------------- | ---------------- | ------------------ |
| 클러스터 이름 | my-first-cluster | 알아보기 쉬운 이름 |
| 인프라        | AWS Fargate      | 서버리스 선택      |

**⚠️ 주의사항:**

- EC2를 선택하면 인스턴스 타입, 수량 등을 추가로 설정해야 함
- CPU 아키텍처 확인 필요 (대부분 AMD64/x86-64)

**완료:**

```bash
✓ 클러스터 생성 완료!
→ 다음: 태스크 정의 만들기

```

---

## 4단계: 태스크 정의 만들기

### 태스크 정의가 뭔가요?

**Docker Compose와 같은 역할**을 하는 설정 파일입니다.

```yaml
# Docker Compose 파일 (참고)
services:
  nginx:
    image: my-nginx:1
    ports:
      - "80:80"
  web:
    image: my-web:1
    ports:
      - "8080:8080"
```

```json
// AWS ECS 태스크 정의 (JSON 형식)
{
  "family": "my-task",
  "containerDefinitions": [
    {
      "name": "nginx",
      "image": "docker.io/myid/nginx:1",
      "portMappings": [{ "containerPort": 80 }]
    },
    {
      "name": "web",
      "image": "docker.io/myid/web:1",
      "portMappings": [{ "containerPort": 8080 }]
    }
  ]
}
```

**핵심:**

- 어떤 이미지를 사용할지
- 어떤 포트를 열지
- CPU/메모리를 얼마나 할당할지

### 태스크 정의 생성 시작

```
ECS 대시보드
    ↓
[태스크 정의] 메뉴
    ↓
[새 태스크 정의 생성] 버튼

```

### 인프라 설정

**1. 기본 설정**

| 항목      | 권장값       | 설명                    |
| --------- | ------------ | ----------------------- |
| 시작 유형 | AWS Fargate  | 서버리스                |
| 운영 체제 | Linux/X86_64 | 대부분의 경우           |
| CPU       | 1 vCPU       | 0.25, 0.5, 1, 2 중 선택 |
| 메모리    | 2 GB         | CPU에 따라 옵션 다름    |

**💡 CPU/메모리 조합 예시:**

```
CPU 0.25 → 메모리 0.5GB ~ 2GB
CPU 0.5  → 메모리 1GB ~ 4GB
CPU 1    → 메모리 2GB ~ 8GB
CPU 2    → 메모리 4GB ~ 16GB

```

**⚠️ 주의:**

- 태스크에 할당한 CPU/메모리를 컨테이너들이 **나눠서 사용**
- 웹서버 + Nginx → 최소 1 vCPU, 2GB 권장

---

### 컨테이너 설정 - 웹서버

**컨테이너 1: 웹서버 추가**

```
[컨테이너 추가] 버튼 클릭

```

**기본 정보:**

| 항목          | 값 예시                    | 설명               |
| ------------- | -------------------------- | ------------------ |
| 컨테이너 이름 | my-webserver               | 식별하기 쉬운 이름 |
| 이미지 URI    | docker.io/myid/webserver:1 | Docker Hub 경로    |

**이미지 URI 형식:**

```
docker.io/[Docker Hub ID]/[리포지토리명]:[태그]

예시:
docker.io/john123/nodejs-server:latest
docker.io/john123/nodejs-server:v1.0

```

**포트 매핑:**

| 이름           | 컨테이너 포트 | 프로토콜 |
| -------------- | ------------- | -------- |
| webserver-port | 8080          | TCP      |

**💡 포트 매핑 팁:**

- 웹서버는 Nginx를 통해서만 접근할 예정
- 포트 매핑을 비워둬도 OK (내부 통신만 사용)

**리소스 할당:**

```
CPU: 0.5 단위 (전체 1 vCPU 중)
메모리:
  - Soft limit: 1024 MB (최소 보장)
  - Hard limit: 비워둠 (무제한)

```

**메모리 제한 이해하기:**

```
Soft Limit (1024 MB)
    ↓
컨테이너가 기본적으로 사용할 메모리
    ↓
필요시 더 사용 가능
    ↓
Hard Limit 도달 시 → 컨테이너 강제 종료

```

**Node.js 서버의 경우:**

- 최소 1GB 메모리 권장
- Soft limit: 1024 MB 설정

---

### 컨테이너 설정 - Nginx

**컨테이너 2: Nginx 추가**

```
[컨테이너 추가] 버튼 클릭

```

**기본 정보:**

| 항목          | 값 예시                |
| ------------- | ---------------------- |
| 컨테이너 이름 | my-nginx               |
| 이미지 URI    | docker.io/myid/nginx:1 |

**포트 매핑:**

| 이름       | 컨테이너 포트 | 프로토콜 |
| ---------- | ------------- | -------- |
| nginx-port | 80            | TCP      |

**⚠️ 중요:**

- Nginx는 외부에서 접근해야 하므로 **포트 매핑 필수**

**리소스 할당:**

```
CPU: 0.5 단위
메모리 Soft limit: 512 MB

```

---

## 5단계: Health Check 설정

### Health Check가 뭔가요?

컨테이너가 **정상적으로 작동하는지 자동으로 확인**하는 기능입니다.

```
컨테이너 실행
    ↓
매 X초마다 확인
    ↓
정상? → 계속 실행
비정상? → 재시작 또는 알림

```

**실제 동작:**

```bash
# Health Check가 자동으로 실행하는 명령어
curl -f http://localhost:8080 || exit 1

```

**왜 필요한가요?**

- ✅ 자동 모니터링
- ✅ 문제 발생 시 자동 재시작
- ✅ 배포 시 안전성 확보

### curl 사용하기

**웹서버 컨테이너 Health Check:**

```
명령: CMD-SHELL,curl -f http://localhost:8080 || exit 1
간격: 30초
제한 시간: 5초
재시도: 3회
시작 기간: 60초

```

**명령어 분석:**

```bash
CMD-SHELL              # bash 같은 기본 셸 사용
curl -f                # HTTP 요청 보내기 (-f는 실패시 에러 반환)
http://localhost:8080  # 확인할 주소
||                     # 또는 (실패하면)
exit 1                 # 종료 코드 1 (실패 신호)

```

**설정값 이해:**

| 설정      | 의미                    | 권장값 |
| --------- | ----------------------- | ------ |
| 간격      | 체크 주기               | 30초   |
| 제한 시간 | 응답 대기 시간          | 5초    |
| 재시도    | 연속 실패 허용          | 3회    |
| 시작 기간 | 처음 체크 시작까지 여유 | 60초   |

**Nginx 컨테이너 Health Check:**

```
명령: CMD-SHELL,curl -f http://localhost:80 || exit 1
간격: 30초
제한 시간: 5초
재시도: 3회
시작 기간: 60초

```

### curl이 없을 때

**문제 상황:**

```bash
# 어떤 이미지는 curl이 설치되어 있지 않음
node:20-slim  # curl 없음
alpine        # curl 없음

```

**해결 방법 1: wget 사용**

```bash
CMD-SHELL,wget --spider http://localhost:8080 || exit 1

```

**해결 방법 2: bash TCP 기능 사용 (추천)**

```bash
CMD-SHELL,timeout 10s bash -c ': > /dev/tcp/localhost/8080' || exit 1

```

**명령어 분석:**

```bash
timeout 10s           # 10초 제한
bash -c               # bash 명령어 실행
': > /dev/tcp/...'    # TCP 연결 시도

```

**bash TCP 사용법 이해:**

```bash
/dev/tcp/localhost/8080  # localhost:8080에 TCP 연결

: >                      # 빈 값을 전송
                         # (디렉터리 열기 방지)

```

**⚠️ 주의사항:**

- 이미지에 bash가 있어야 함
- sh만 있는 경우는 사용 불가

**해결 방법 3: Dockerfile에 curl 설치**

```docker
FROM node:20-slim

# curl 설치
RUN apt-get update && apt-get install -y curl

# 나머지 설정...

```

---

## 환경 변수 설정 (선택사항)

**필요한 경우:**

```
환경 변수 추가
    ↓
키: NODE_ENV
값: production

키: PORT
값: 8080

```

---

## 로깅 설정

**권장 설정:**

```
✓ awslogs 사용
로그 그룹: /ecs/my-task
로그 스트림 접두사: ecs

```

**왜 필요한가요?**

- 에러 발생 시 로그 확인 가능
- CloudWatch에서 실시간 모니터링

---

## 🎓 핵심 요약

### 전체 흐름

```
1. AWS 가입 및 리전 선택
    ↓
2. 클러스터 생성 (Fargate)
    ↓
3. 태스크 정의 작성
   - 인프라 설정 (CPU/메모리)
   - 컨테이너 추가 (웹서버, Nginx)
   - Health Check 설정
    ↓
4. 태스크 정의 생성 완료

```

### 핵심 포인트

| 개념        | 설명               | 비유        |
| ----------- | ------------------ | ----------- |
| 클러스터    | 컴퓨터 자원 그룹   | 아파트 단지 |
| 서비스      | 태스크 관리자      | 관리사무소  |
| 태스크      | 실행 중인 컨테이너 | 각 집       |
| 태스크 정의 | 설정 파일          | 설계도      |

### 리소스 권장 설정

```
태스크 전체: CPU 1, 메모리 2GB
    ↓
웹서버: CPU 0.5, 메모리 1GB
Nginx:  CPU 0.5, 메모리 512MB

```

### Health Check 핵심

```bash
# curl이 있는 경우
curl -f http://localhost:8080 || exit 1

# bash만 있는 경우
timeout 10s bash -c ': > /dev/tcp/localhost/8080' || exit 1

```

---

## 🔍 다음 단계

다음 튜토리얼에서는:

1. **서비스 생성하기**
   - 태스크 정의를 기반으로 서비스 만들기
   - 로드 밸런서 설정
2. **네트워크 설정**
   - VPC와 서브넷 이해
   - 보안 그룹 설정
3. **실제 배포**
   - 태스크 실행
   - 외부 접속 확인
4. **모니터링 및 관리**
   - CloudWatch 로그 확인
   - 자동 스케일링 설정

---

## 🔧 트러블슈팅

### 문제 1: 이미지 URI 오류

**증상:**

```
Error: Unable to pull image

```

**해결:**

```bash
# Docker Hub 이미지 확인
docker.io/[정확한ID]/[정확한리포지토리명]:[존재하는태그]

# 예시
docker.io/john123/myapp:latest  ✓
docker.io/john123/myapp:v1      ✓
docker.io/John123/myapp:latest  ✗ (대소문자 구분)

```

### 문제 2: CPU 아키텍처 불일치

**증상:**

```
exec format error

```

**해결:**

```bash
# 이미지 빌드 시 아키텍처 지정
docker build --platform linux/amd64 -t myapp:1 .

# ECS에서 동일한 아키텍처 선택
운영 체제: Linux/X86_64

```

### 문제 3: Health Check 실패

**증상:**

```
Container unhealthy

```

**해결 순서:**

1. 컨테이너에 직접 접속해서 curl 테스트
2. curl이 없으면 bash TCP 방식 사용
3. 시작 기간을 60초로 늘림 (앱 시작 시간 고려)

```bash
# 수동 테스트
docker exec -it [컨테이너ID] bash
curl localhost:8080

```

### 문제 4: 메모리 부족

**증상:**

```
OutOfMemoryError

```

**해결:**

```
태스크 메모리 증가
1 vCPU, 2GB → 1 vCPU, 4GB

또는

컨테이너별 메모리 재분배
웹서버: 1GB → 1.5GB
Nginx: 512MB → 512MB

```

---

## 💡 실전 팁

### 1. 비용 관리

```
테스트 후 바로 삭제하기
    ↓
서비스 중지
    ↓
태스크 정의 비활성화
    ↓
클러스터 삭제

```

### 2. 이미지 최적화

```
- node:20-slim 같은 slim 이미지 사용
- 멀티 스테이지 빌드 활용
- 불필요한 파일 제거

```

### 3. 로그 활용

```
CloudWatch Logs
    ↓
실시간 모니터링
    ↓
에러 패턴 분석
    ↓
알람 설정

```

---

## 📚 참고 자료

- [AWS ECS 공식 문서](https://docs.aws.amazon.com/ecs/)
- [Fargate 요금 계산기](https://aws.amazon.com/fargate/pricing/)
- [Docker Hub](https://hub.docker.com/)

---

# 강의 스크립트

**0:00 클러스터 만들기**

**4:07 태스크 정의 만들기**

**8:11 health check 기능 설명**

**11:32 nginx 컨테이너도 추가하자**

- 저번시간에 nginx랑 웹서버 이미지 2개를 Docker hub에 올려놓으라고했는데 그 상태에서 시작해보도록 합시다.
- 그리고 AWS 사이트 가입하고 카드등록까지 해옵시다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%984.png)

▲ AWS 사이트 방문하면 우측 상단에 지역을 선택할 수 있는데

서울에서 서비스할거면 서울 고르고 검색창에서 ECS 검색해서 들어갑시다.

> EC2 vs Fargate

컨테이너 띄우려면 1. 클러스터 만들고 2. 서비스 만들고 3. 태스크 만들면 됩니다.

그래서 ECS 검색해서 들어가서 클러스터 생성부터 눌러봅시다.

클러스터는 프로젝트 하나라고 생각하면 되는데

근데 정확하는 **내가 컴퓨터를 몇대나 미리 점유할건지** 정하려고 클러스터를 만드는겁니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%985.png)

▲ 클러스터 하나 생성하려면 인프라부터 고르라고 되어있을 겁니다.

EC2는 컴퓨터를 직접 빌릴 수 있는 상품이고 Fargate는 서버리스형태로 CPU, RAM을 필요할 때만 꺼내쓰는 방식입니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%986.png)

▲ 그래서 EC2를 고르면 컴퓨터를 원하는 용량과 갯수로 빌릴 수 있습니다.

AWS 처음 카드등록하면 t2.micro 또는 t3.micro 라는 똥컴하나 1년무료 이용권주는데 그걸 쓸 수도 있습니다.

참고로 이미지 만들 때 사용했던 CPU 아키텍쳐와 같은 컴퓨터를 빌려야 잘돌아갑니다.

대부분 AMD64 (일명 x86-64) 라는 CPU 아키텍처로 만들었을거라 그게 표기된 컴퓨터를 빌려야합니다.

드물게 ARM64로 이미지를 빌드했으면 그게 표기된 컴퓨터를 빌려서 씁시다.

근데 Fargate라는 옵션을 쓰면 컴퓨터를 미리 점유하는게 아니라

여러분이 필요할 때 마다 컴퓨터자원을 마법처럼 끌어다가 쓸 수 있습니다.

EC2보다 요금이 20% 정도 더 비싸지만 편하니까 이걸 씁시다.

서비스 만들어보고 바로 지우면 요금도 몇백원 나올까말까 하니까

그냥 까까 사먹을 돈으로 이런거 경험해보도록 합시다.

아무튼 다른건 딱히 건드릴 필요 없고 클러스터 이름 아무거나 잘 지어서 생성이나 해봅시다.

> 태스크 정의 (task definition)

클러스터 → 서비스 → 태스크를 띄운다고 했는데

참고로 서비스 없이 클러스터 → 태스크만 띄울 수도 있습니다.

1회성 작업같은걸 하는 이미지 띄울 때는 그래도 상관없음

근데 지속적으로 안정적으로 실행되어야하는 이미지는 서비스 안에 넣는게 좋습니다.

왜냐면 서비스 안에 태스크를 넣으면

하나가 망가졌을 때 자동으로 새로운 태스크로 갈아치우는 기능,

중단없이 태스크를 업데이트할 수 있는 기능 같은게 있어서 그렇습니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%982.png)

▲ 아무튼 클러스터 안에서 서비스, 태스크를 실행할 수 있는데

그 전에 **태스크 정의**라는게 있어야 서비스나 태스크를 실행할 수 있습니다.

어딘가에 있는 태스크 정의 만드는 버튼을 눌러봅시다.

태스크 정의는 태스크를 어떻게 띄울지 정의하는 파일입니다.

"무슨 이미지들을 어떤 포트에 어떤 환경변수를 넣어서 띄울지" 쭉 작성하는 파일일 뿐이고

실은 docker compose 파일이랑 똑같습니다.

하지만 ECS 문법에 따라 .json 형식으로 작성해야할 뿐인데

.json 그딴거 모르겠으면 웹페이지에서 클릭질로 작성할 수 있게 되어있습니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%983.png)

▲ 태스크 정의 만들기 누르면 일단 인프라를 또 고르게 합니다.

클러스터에서 예약해놨던 컴퓨터를 태스크 1개가 얼마나 점유할 것인지 정하는 부분입니다.

그래서 이 태스크가 얼마의 CPU, 메모리가 필요한지 정하면 되겠습니다.

사진에선 CPU 1개, 메모리 2GB를 골라봤는데

이 태스크 안에 컨테이너가 여러개 있을 예정이면 CPU 1개, 메모리 2GB를 컨테이너간 나눠써야합니다.

나중에 변경 가능하니까 대충합시다.

> 태스크 정의 안에 컨테이너 작성하기

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%984-1.png)

▲ 태스크 정의 안엔 컨테이너를 어떻게 띄울지 작성할 수 있습니다.

우리는 nginx, 웹서버를 띄울 것이기 때문에 2개 띄운다고 작성하면 됩니다.

일단 첫 컨테이너엔 웹서버 컨테이너 띄운다고 이름이랑 이미지 다운받을 수 있는 경로를 작성해봤습니다.

docker hub에 올려놨을 경우엔 **docker.io/내아이디/리포지토리명:태그명** 입력하면 됩니다.

사진처럼 포트도 설정할 수 있습니다.

근데 웹서버는 nginx에서 접속할거라 포트를 연결할 필요는 없어보여서 지워도 될듯 하군요.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%985-1.png)

▲ 컨테이너마다 CPU, 메모리를 얼마나 할당할 것인지 정할 수 있습니다.

아까 저는 태스크에 CPU 1개, 메모리 2GB를 할당했는데

그 안에서 nginx, 웹서버는 각각 얼마의 CPU, 메모리를 점유할지 맘대로 결정하면 됩니다.

메모리 제한도 설정할 수 있는데 soft limit은 메모리를 얼마나 미리 최소로 선점할지,

hard limit은 최댓값입니다.

hard limit 설정하면 그걸 도달하는 경우 컨테이너가 강제종료 될텐데 아마 비워도 상관없음

nodejs 서버의 경우에는 최소 메모리 1GB는 주는게 좋습니다.

나중에 테스트해보면서 늘리거나 줄이거나 해도 됩니다.

이외에 환경변수, 로깅옵션 이런건 필요할 때 사용합시다.

처음엔 에러났을 때 상세히 볼게 필요하기 때문에 로깅하라고 해놓는게 좋습니다.

> 상태확인 (healthcheck)

새로운 개념 하나만 배우고 갑시다.

내 nodejs 웹서버 컨테이너가 잘 떠있는지 확인하고 싶으면 어떻게 하죠?

웹브라우저 켜서 들어가보면 되겠지만 포트 연결을 안해놨으면 그건 좀 어려울 수 있습니다.

가장 쉬운 방법은 nodejs 웹서버 컨테이너에 접속해서 localhost:8080으로 들어가보면 됩니다.

터미널로 들어갈 수 있으니까 아마 curl localhost:8080 이런거 쳐보면 알 수 있겠군요.

근데 그 작업을 자동화해줄 수도 있습니다.

자동으로 니가 알아서 5초마다 curl localhost:8080 쳐보라고 할 수 있는데 그걸 멋있는 말로 healthcheck라고 합니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%BA%A1%EC%B2%986-1.png)

▲ 그래서 여기에 터미널 명령어를 적으면 그걸 얘가 컨테이너 안에서 자동으로 X초마다 실행해줍니다.

일종의 컨테이너 모니터링 방법이라고 생각하면 되겠습니다.

CMD-SHELL, curl -f http://localhost:8080 || exit 1

그냥 기본적으로 이거 채우고 시작하면 되는데

CMD-SHELL 이건 bash같은 기본적인 쉘을 쓰라는 것이고

그 오른쪽에 명령어 입력하면 되는데 대부분 curl 이런거 쓰면 됩니다.

그리고 curl 요청이 실패하면 exit 1 하라고 코드짜면 되는데 exit 1 이런게 헬스체크를 실패했다는 암구호같은 거라 써주면 됩니다.

그리고 밑에 몇초마다 할건지 이런건 쭉 읽어보면서 알아서 적으면 됩니다.

> curl 있나 확인하는 것도 좋음

근데 가끔 curl 이런 기본 프로그램이 설치 안되어있는 이미지나 OS가 있습니다.

예를 들어 node:20-slim 이런 것도 이미지에 curl이 설치안되어있을 수 있는데

그래서 이거 실행하기 전에 직접 컨테이너에 들어가서 curl 커맨드 잘 되나 확인해보는것도 좋습니다.

curl이 없으면

- wget 그런거 찾아서 써도 되고
- 이미지에 직접 curl 설치하라고 Dockerfile에 기재해도 되고
- bash 정도는 있으면 bash 내장 기능중에 특정 페이지로 요청해주는 그런 비밀기능이 있어서 그거 써도 됩니다.

```
timeout 10s bash -c ': > /dev/tcp/localhost/8080' || exit 1
```

▲ bash에서 /dev/tcp/localhost/8080 이런식으로 적으면 신기하게도 localhost:8080에 TCP 요청을 날려줍니다.

TCP요청은 그냥 접속해본다는 뜻이고

이미지에 bash가 있으면 이걸 써서 헬스체크 하셔도 됩니다.

근데 그냥 /dev/tcp/localhost/8080 이렇게 입력만 하면 그 디렉터리 열라는 뜻이 될 수 있어서

그걸 방지하려고 : > 이런 이상한 기호도 쓰면 됩니다.

: 이건 텅빈 값이라는 뜻이고

> 이건 왼쪽 값을 오른쪽에 작성하라는 뜻입니다.

그래서 텅빈 값을 그 경로에 넣으라고 의미없는 명령어를 추가해준 것인데 그래야 잘동작합니다.

> nginx 컨테이너도 띄우기

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/12/%EC%A0%9C%EB%AA%A9-%EC%97%86%EC%9D%8C1.png)

▲ 웹서버 컨테이너 말고 **nginx 컨테이너**도 띄워야하니까 컨테이너 하나 추가해서 잘 입력해봅시다.

컨테이너 이름, URI, 포트는 80:80, CPU와 메모리 적절히, healthcheck는 기본명령어

이런거 설정하는 것 말고는 딱히 건드릴게 없으니 알아서 남자답게 채워봅시다.

아무튼 다 됐으면 **태스크 정의 생성** 눌러보면 되겠습니다.

이제 클러스터 들어가서 서비스 생성 누르고 태스크 골라서 띄우면 되는데 그건 다음에 해보도록 합시다.
