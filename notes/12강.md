# 12. Docker compose 2. network, volume

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Compose에서 여러 네트워크를 직접 생성하고 관리
- 컨테이너별로 필요한 네트워크만 연결하여 보안 강화
- Volume을 Docker Compose에서 관리하는 방법 이해
- 컨테이너 자동 재시작 설정

---

## 📚 사전 지식

- Docker Compose 기본 사용법
- Docker Network의 개념
- Volume의 개념
- 이전 강의의 Nginx, 웹서버 설정

---

## Docker Compose를 사용하는 이유

매번 긴 `docker run` 명령어를 입력하는 대신, Docker Compose 파일에 설정을 기록해두면:

- ✅ 명령어가 간결해집니다
- ✅ 설정을 파일로 관리할 수 있습니다
- ✅ 여러 컨테이너를 한 번에 실행/중지할 수 있습니다
- ✅ 팀원들과 설정을 공유하기 쉽습니다

---

## 1단계: 여러 네트워크 만들기

### 왜 여러 네트워크가 필요한가요?

기본적으로 Docker Compose는 모든 서비스를 하나의 네트워크에 담습니다. 하지만 보안을 위해 통신이 필요한 컨테이너끼리만 네트워크를 공유하고 싶을 때가 있습니다.

**예시 상황:**

```
nginx     <->  웹서버  (통신 필요 ✅)
웹서버    <->  DB      (통신 필요 ✅)
nginx     <->  DB      (통신 불필요 ❌)

```

### 네트워크 구조 설계

Nginx와 웹서버는 mynet1에, 웹서버와 DB는 mynet2에 배치하여 필요한 통신만 허용할 수 있습니다. 하나의 컨테이너는 여러 네트워크에 동시에 속할 수 있습니다.

```
[mynet1 네트워크]
  - nginx
  - webserver

[mynet2 네트워크]
  - webserver
  - db

```

### docker-compose.yml 작성

```yaml
services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080
    networks:
      - mynet1
      - mynet2

  nginx:
    image: nginx:1
    ports:
      - 80:80
    networks:
      - mynet1

  db:
    image: postgres:17-alpine
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=qwer1234
    networks:
      - mynet2

networks:
  mynet1:
  mynet2:
```

### 설정 설명

- **`networks:`** (최상단): 생성할 네트워크 이름을 정의합니다
- **`networks:`** (서비스 안): 각 서비스가 속할 네트워크를 지정합니다
- **webserver**: 두 네트워크에 모두 속해서 nginx와 db 모두와 통신 가능
- **nginx**: mynet1만 접근 가능 (db와 직접 통신 불가)
- **db**: mynet2만 접근 가능 (nginx와 직접 통신 불가)

---

## 2단계: Volume 사용하기

### Volume이 필요한 이유

데이터베이스처럼 데이터를 영구적으로 보관해야 하는 서비스는 컨테이너가 삭제되어도 데이터가 유지되도록 Volume을 사용해야 합니다.

### 기존 Volume 사용하기

```yaml
services:
  db:
    image: postgres:17-alpine
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=qwer1234
    volumes:
      - 볼륨이름:/var/lib/postgresql/data

volumes:
  볼륨이름:
    external: true
```

### 설정 설명

- **`volumes:`** (서비스 안): `볼륨이름:컨테이너내부경로` 형식으로 작성
- **`volumes:`** (최상단): 사용할 볼륨 정의
- **`external: true`**: 기존에 생성된 볼륨을 사용하겠다는 의미. 이것이 없으면 Docker Compose가 새로운 볼륨을 자동으로 생성합니다

### Bind Mount 사용하기

현재 디렉토리의 폴더를 볼륨으로 사용하려면:

```yaml
services:
  db:
    image: postgres:17-alpine
    volumes:
      - ./vol:/var/lib/postgresql/data
```

**`./vol`**: docker-compose.yml 파일과 같은 위치의 `vol` 폴더를 사용

---

## 3단계: 자동 재시작 설정

### 왜 필요한가요?

웹서버는 사용자가 많거나 코드 오류로 인해 프로그램이 종료될 수 있습니다. 이런 경우 자동으로 재시작되도록 설정할 수 있습니다.

### restart: always 옵션

```yaml
services:
  nginx:
    image: nginx:1
    ports:
      - 80:80
    restart: always
```

**동작 방식:**

- ✅ 컨테이너가 오류로 종료되면 자동 재시작
- ✅ Docker 엔진이 재시작되어도 자동으로 서비스 시작
- ❌ 사용자가 `docker stop` 명령으로 중지한 경우는 재시작 안 됨

### restart: unless-stopped 옵션 (권장)

```yaml
services:
  nginx:
    image: nginx:1
    ports:
      - 80:80
    restart: unless-stopped
```

**always와의 차이점:**

- ✅ 컨테이너 오류 시 자동 재시작
- ❌ Docker 엔진 재시작 시 자동 시작 안 됨
- ❌ 사용자가 명령어로 중지한 경우 재시작 안 됨

**실무에서는 `unless-stopped`를 주로 사용합니다.**

---

## 4단계: 자동 재시작 테스트하기

### 방법 1: Docker Desktop 재시작

1. Docker Desktop을 완전히 종료
2. 다시 시작
3. 컨테이너 목록 확인

### 방법 2: 프로세스 강제 종료

```bash
# 1. 컨테이너 내부로 접속
docker exec -it [컨테이너이름] sh

# 2. 실행 중인 프로세스 확인
ps

# 3. 메인 프로세스(PID 1) 강제 종료
kill 1

```

**결과 확인:**

- `restart: always` 또는 `unless-stopped` 설정 시 → 자동으로 재시작됨
- Inspect 메뉴에서 "RestartCount" 항목 확인 가능

---

## 💡 전체 docker-compose.yml 예시

```yaml
services:
  webserver:
    image: nodeserver:v1
    ports:
      - "8080:8080"
    # depends_on: 이 서비스가 시작되기 전에 먼저 시작되어야 할 서비스 지정
    # db가 먼저 시작된 후 webserver가 시작됨 (단, db가 완전히 준비될 때까지 기다리지는 않음)
    depends_on:
      - "db"
    networks:
      - mynet1 # nginx와 통신 가능
      - mynet2 # db와 통신 가능
    # 추천: restart 정책 추가
    restart: unless-stopped

  nginx:
    image: nginx:v1
    ports:
      - "80:80"
    # volumes: Bind Mount 방식 사용
    # 호스트의 ./nginx/myconfig1.conf 파일을 컨테이너 내부로 직접 마운트
    # 파일 수정 시 컨테이너 재시작만으로 반영 가능 (이미지 재빌드 불필요)
    volumes:
      - ./nginx/myconfig1.conf:/etc/nginx/conf.d/myconfig1.conf
    depends_on:
      - webserver
    networks:
      - mynet1
    # restart: always - 오류 발생 시, Docker 재시작 시 모두 자동 실행
    restart: always
    # 추천: unless-stopped로 변경 (더 안전함)
    # restart: unless-stopped

  db:
    image: postgres:18.0-alpine
    environment:
      # ${POSTGRES_USER}: .env 파일에서 환경변수를 읽어옴
      # .env 파일에 POSTGRES_USER=admin 형태로 저장되어 있어야 함
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      # "5431:5432" - 호스트의 5431 포트를 컨테이너의 5432 포트에 연결
      # (기본 5432를 피하기 위해 5431 사용 - 좋은 선택!)
      - "5431:5432"
    networks:
      - mynet2
    volumes:
      # Named Volume 방식 사용
      # Docker가 관리하는 test_vol 볼륨을 DB 데이터 디렉토리에 마운트
      - test_vol:/var/lib/postgresql/data
    # 추천: restart 정책 추가
    restart: unless-stopped

networks:
  mynet1: # nginx-webserver 간 통신용 네트워크
  mynet2: # webserver-db 간 통신용 네트워크

volumes:
  test_vol:
    # external: true - 이미 생성된 test_vol 볼륨을 사용
    # 사전에 'docker volume create test_vol' 명령으로 볼륨 생성 필요
    external: true
```

추가 설명:

```yaml
# Bind Mount 방식으로 사용하려면:
volumes:
  - ./vol:/var/lib/postgresql/data
  # ./vol: 현재 docker-compose.yml 파일이 있는 위치의 vol 폴더를 의미
  # 호스트 컴퓨터의 실제 폴더를 직접 마운트하는 방식

# restart 옵션 종류:
restart: "no"            # 재시작 안 함 (기본값, 따옴표 필수)
restart: always          # 항상 재시작 (Docker 재시작 시에도 자동 실행)
restart: on-failure      # 오류로 종료된 경우에만 재시작
restart: unless-stopped  # 사용자가 직접 중지하지 않는 한 재시작 (권장)

# 하나의 서비스가 여러 네트워크에 속할 수 있음:
networks:
  - mynet1  # nginx와 통신 가능
  - mynet2  # db와 통신 가능
# 이렇게 하면 webserver는 두 네트워크의 다리 역할을 하게 됨
```

---

## 🎓 핵심 요약

1. **여러 네트워크 생성**: 최상단에 `networks:` 정의하고, 각 서비스에서 필요한 네트워크만 지정
2. **Volume 관리**: `external: true`로 기존 볼륨 사용, 또는 `./폴더명`으로 bind mount
3. **자동 재시작**: `restart: unless-stopped`로 안정적인 서비스 운영
4. **보안 강화**: 불필요한 컨테이너 간 통신을 네트워크로 차단

---

## 💡 실습 과제

1. nginx, 웹서버, DB를 위 예시대로 설정하고 실행해보세요
2. nginx 컨테이너에 접속해서 `ping db` 명령이 실패하는지 확인해보세요 (네트워크 격리 확인)
3. 웹서버 컨테이너에서는 `ping db`와 `ping nginx` 모두 성공하는지 확인해보세요
4. nginx 프로세스를 강제 종료하고 자동으로 재시작되는지 확인해보세요

---
