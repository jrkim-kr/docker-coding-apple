# 12. Docker compose 2. network, volume

# 핵심 정리

## 🎯 학습 목표

이 튜토리얼을 마치면 다음을 할 수 있습니다:

- Docker Compose에서 여러 네트워크를 직접 생성하고 관리
- 컨테이너별로 필요한 네트워크만 연결하여 보안 강화
- Volume을 Docker Compose에서 관리하는 방법 이해
- 컨테이너 자동 재시작 설정

---

## 📚 사전 지식

- Docker Compose 기본 사용법
- Docker Network의 개념
- Volume의 개념
- 이전 강의의 Nginx, 웹서버 설정

---

## Docker Compose를 사용하는 이유

매번 긴 `docker run` 명령어를 입력하는 대신, Docker Compose 파일에 설정을 기록해두면:

- ✅ 명령어가 간결해집니다
- ✅ 설정을 파일로 관리할 수 있습니다
- ✅ 여러 컨테이너를 한 번에 실행/중지할 수 있습니다
- ✅ 팀원들과 설정을 공유하기 쉽습니다

---

## 1단계: 여러 네트워크 만들기

### 왜 여러 네트워크가 필요한가요?

기본적으로 Docker Compose는 모든 서비스를 하나의 네트워크에 담습니다. 하지만 보안을 위해 통신이 필요한 컨테이너끼리만 네트워크를 공유하고 싶을 때가 있습니다.

**예시 상황:**

```
nginx     <->  웹서버  (통신 필요 ✅)
웹서버    <->  DB      (통신 필요 ✅)
nginx     <->  DB      (통신 불필요 ❌)

```

### 네트워크 구조 설계

Nginx와 웹서버는 mynet1에, 웹서버와 DB는 mynet2에 배치하여 필요한 통신만 허용할 수 있습니다. 하나의 컨테이너는 여러 네트워크에 동시에 속할 수 있습니다.

```
[mynet1 네트워크]
  - nginx
  - webserver

[mynet2 네트워크]
  - webserver
  - db

```

### docker-compose.yml 작성

```yaml
services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080
    networks:
      - mynet1
      - mynet2

  nginx:
    image: nginx:1
    ports:
      - 80:80
    networks:
      - mynet1

  db:
    image: postgres:17-alpine
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=qwer1234
    networks:
      - mynet2

networks:
  mynet1:
  mynet2:
```

### 설정 설명

- **`networks:`** (최상단): 생성할 네트워크 이름을 정의합니다
- **`networks:`** (서비스 안): 각 서비스가 속할 네트워크를 지정합니다
- **webserver**: 두 네트워크에 모두 속해서 nginx와 db 모두와 통신 가능
- **nginx**: mynet1만 접근 가능 (db와 직접 통신 불가)
- **db**: mynet2만 접근 가능 (nginx와 직접 통신 불가)

---

## 2단계: Volume 사용하기

### Volume이 필요한 이유

데이터베이스처럼 데이터를 영구적으로 보관해야 하는 서비스는 컨테이너가 삭제되어도 데이터가 유지되도록 Volume을 사용해야 합니다.

### 기존 Volume 사용하기

```yaml
services:
  db:
    image: postgres:17-alpine
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=qwer1234
    volumes:
      - 볼륨이름:/var/lib/postgresql/data

volumes:
  볼륨이름:
    external: true
```

### 설정 설명

- **`volumes:`** (서비스 안): `볼륨이름:컨테이너내부경로` 형식으로 작성
- **`volumes:`** (최상단): 사용할 볼륨 정의
- **`external: true`**: 기존에 생성된 볼륨을 사용하겠다는 의미. 이것이 없으면 Docker Compose가 새로운 볼륨을 자동으로 생성합니다

### Bind Mount 사용하기

현재 디렉토리의 폴더를 볼륨으로 사용하려면:

```yaml
services:
  db:
    image: postgres:17-alpine
    volumes:
      - ./vol:/var/lib/postgresql/data
```

**`./vol`**: docker-compose.yml 파일과 같은 위치의 `vol` 폴더를 사용

---

## 3단계: 자동 재시작 설정

### 왜 필요한가요?

웹서버는 사용자가 많거나 코드 오류로 인해 프로그램이 종료될 수 있습니다. 이런 경우 자동으로 재시작되도록 설정할 수 있습니다.

### restart: always 옵션

```yaml
services:
  nginx:
    image: nginx:1
    ports:
      - 80:80
    restart: always
```

**동작 방식:**

- ✅ 컨테이너가 오류로 종료되면 자동 재시작
- ✅ Docker 엔진이 재시작되어도 자동으로 서비스 시작
- ❌ 사용자가 `docker stop` 명령으로 중지한 경우는 재시작 안 됨

### restart: unless-stopped 옵션 (권장)

```yaml
services:
  nginx:
    image: nginx:1
    ports:
      - 80:80
    restart: unless-stopped
```

**always와의 차이점:**

- ✅ 컨테이너 오류 시 자동 재시작
- ❌ Docker 엔진 재시작 시 자동 시작 안 됨
- ❌ 사용자가 명령어로 중지한 경우 재시작 안 됨

**실무에서는 `unless-stopped`를 주로 사용합니다.**

---

## 4단계: 자동 재시작 테스트하기

### 방법 1: Docker Desktop 재시작

1. Docker Desktop을 완전히 종료
2. 다시 시작
3. 컨테이너 목록 확인

### 방법 2: 프로세스 강제 종료

```bash
# 1. 컨테이너 내부로 접속
docker exec -it [컨테이너이름] sh

# 2. 실행 중인 프로세스 확인
ps

# 3. 메인 프로세스(PID 1) 강제 종료
kill 1

```

**결과 확인:**

- `restart: always` 또는 `unless-stopped` 설정 시 → 자동으로 재시작됨
- Inspect 메뉴에서 "RestartCount" 항목 확인 가능

---

## 💡 전체 docker-compose.yml 예시

```yaml
services:
  webserver:
    image: nodeserver:v1
    ports:
      - "8080:8080"
    # depends_on: 이 서비스가 시작되기 전에 먼저 시작되어야 할 서비스 지정
    # db가 먼저 시작된 후 webserver가 시작됨 (단, db가 완전히 준비될 때까지 기다리지는 않음)
    depends_on:
      - "db"
    networks:
      - mynet1 # nginx와 통신 가능
      - mynet2 # db와 통신 가능
    # 추천: restart 정책 추가
    restart: unless-stopped

  nginx:
    image: nginx:v1
    ports:
      - "80:80"
    # volumes: Bind Mount 방식 사용
    # 호스트의 ./nginx/myconfig1.conf 파일을 컨테이너 내부로 직접 마운트
    # 파일 수정 시 컨테이너 재시작만으로 반영 가능 (이미지 재빌드 불필요)
    volumes:
      - ./nginx/myconfig1.conf:/etc/nginx/conf.d/myconfig1.conf
    depends_on:
      - webserver
    networks:
      - mynet1
    # restart: always - 오류 발생 시, Docker 재시작 시 모두 자동 실행
    restart: always
    # 추천: unless-stopped로 변경 (더 안전함)
    # restart: unless-stopped

  db:
    image: postgres:18.0-alpine
    environment:
      # ${POSTGRES_USER}: .env 파일에서 환경변수를 읽어옴
      # .env 파일에 POSTGRES_USER=admin 형태로 저장되어 있어야 함
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      # "5431:5432" - 호스트의 5431 포트를 컨테이너의 5432 포트에 연결
      # (기본 5432를 피하기 위해 5431 사용 - 좋은 선택!)
      - "5431:5432"
    networks:
      - mynet2
    volumes:
      # Named Volume 방식 사용
      # Docker가 관리하는 test_vol 볼륨을 DB 데이터 디렉토리에 마운트
      - test_vol:/var/lib/postgresql/data
    # 추천: restart 정책 추가
    restart: unless-stopped

networks:
  mynet1: # nginx-webserver 간 통신용 네트워크
  mynet2: # webserver-db 간 통신용 네트워크

volumes:
  test_vol:
    # external: true - 이미 생성된 test_vol 볼륨을 사용
    # 사전에 'docker volume create test_vol' 명령으로 볼륨 생성 필요
    external: true
```

추가 설명:

```yaml
# Bind Mount 방식으로 사용하려면:
volumes:
  - ./vol:/var/lib/postgresql/data
  # ./vol: 현재 docker-compose.yml 파일이 있는 위치의 vol 폴더를 의미
  # 호스트 컴퓨터의 실제 폴더를 직접 마운트하는 방식

# restart 옵션 종류:
restart: "no"            # 재시작 안 함 (기본값, 따옴표 필수)
restart: always          # 항상 재시작 (Docker 재시작 시에도 자동 실행)
restart: on-failure      # 오류로 종료된 경우에만 재시작
restart: unless-stopped  # 사용자가 직접 중지하지 않는 한 재시작 (권장)

# 하나의 서비스가 여러 네트워크에 속할 수 있음:
networks:
  - mynet1  # nginx와 통신 가능
  - mynet2  # db와 통신 가능
# 이렇게 하면 webserver는 두 네트워크의 다리 역할을 하게 됨
```

---

## 🎓 핵심 요약

1. **여러 네트워크 생성**: 최상단에 `networks:` 정의하고, 각 서비스에서 필요한 네트워크만 지정
2. **Volume 관리**: `external: true`로 기존 볼륨 사용, 또는 `./폴더명`으로 bind mount
3. **자동 재시작**: `restart: unless-stopped`로 안정적인 서비스 운영
4. **보안 강화**: 불필요한 컨테이너 간 통신을 네트워크로 차단

---

## 💡 실습 과제

1. nginx, 웹서버, DB를 위 예시대로 설정하고 실행해보세요
2. nginx 컨테이너에 접속해서 `ping db` 명령이 실패하는지 확인해보세요 (네트워크 격리 확인)
3. 웹서버 컨테이너에서는 `ping db`와 `ping nginx` 모두 성공하는지 확인해보세요
4. nginx 프로세스를 강제 종료하고 자동으로 재시작되는지 확인해보세요

---

# 강의 스크립트

간단한거 띄울 때도 쓸데없는 docker 명령어들 길게 입력하는 것 보다

docker compose 파일에 기록해놓고 실행하는게 훨씬 편해서 앞으로 자주 쓰게 될텐데

그래서 docker compose 사용예시를 좀만 더 알아보도록 합시다.

> 직접 network 만들기

원래 services: 안에 있는 모든 컨테이너들은 자동으로 네트워크 하나 안에 담아줍니다.

그래서 네트워크 따로 설정하고 그럴 필요는 없는데

간혹 네트워크를 여러개 만들어서 컨테이너를 안전하게 배치하고 싶을 때도 있습니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/ZOOM0.png)

예를 들어 nginx, 웹서버, DB가 있으면

**nginx <-> 웹서버**는 서로 통신해야하고

**웹서버 <-> DB**는 서로 통신해야하고

근데 **nginx <-> DB**는 서로 통신할 일이 아마 없습니다.

그래서 각각 통신이 필요한 컨테이너끼리 하나의 네트워크에 보관하는 것도 안전하고 좋을 수 있습니다.

(하나의 컨테이너는 여러개 네트워크에 속할 수 있습니다.)

```yaml
services:
  webserver:
    image: nodeserver:1
    ports:
      - 8080:8080
    networks:
      - mynet1
      - mynet2

  nginx:
    image: nginx:1
    ports:
      - 80:80
    networks:
      - mynet1

  db:
    image: postgres:17-alpine
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=qwer1234
    networks:
      - mynet2

networks:
  mynet1:
  mynet2:
```

그래서 사진처럼 구현해봤습니다.

**networks:** 라는 최상위 항목을 하나 만들어서 안에 네트워크 이름을 넣으면 그 이름으로 네트워크를 만들어줍니다.

위 예시에선 mynet1, mynet2 네트워크를 만들었습니다.

그럼 이제 서비스마다 **networks:** 넣어서 네트워크안에 넣을 수 있습니다.

> volume 사용하기

docker compose 파일 사용할 때도 볼륨 장착하라고 명령가능합니다.

```ruby
services:

  db:
    image: postgres:17-alpine
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=qwer1234
    volumes:
      - 볼륨이름:/var/lib/postgresql/data

volumes:
  볼륨이름:
    external: true
```

volume: 쓰고 그 안에 볼륨장착하는 명령어 입력하면 되겠습니다.

하지만 그냥 쓰면 docker compose 실행시 직접 볼륨을 새로 만들어주기 때문에

그게 싫고 기존에 있던 볼륨을 쓸려면 최상단에 volumes: 넣고 기존 볼륨이름과 external: true를 넣어줘야합니다.

참고로 bind mount 식으로 볼륨을 쓰려면 볼륨이름 대신 여러분들 **폴더경로**를 적어주면 되겠습니다.

예를 들어 docker compose 파일과 같은 경로에 vol 폴더를 볼륨으로 쓰려면

볼륨이름란에 ./vol 이렇게 적는게 어떨까요.

> 기타 명령어들

가끔가다가 프로그램이 혼자 종료되는 상황들이 있습니다.

웹서버의 경우엔 유저가 너무 많거나 이상한 코드가 있거나 그러면 프로그램이 종료될 수 있습니다.

그럴 땐 어떻게 하게요?

꺼지면 자동으로 다시 실행하라고 코드를 짜두거나 그럴 수 있습니다.

- nodejs같은 경우엔 pm2같은 라이브러리 쓰면 다운되거나 그럴 때 그냥 알아서 다시 시작해주고 그렇습니다.
- nginx같은 경우엔 리눅스의 systemctl 같은 프로그램 쓰면 더 간단하고 편할 수 있습니다.

하지만 docker를 쓰는 경우 알아서 재시작해주는 간편한 옵션이 있습니다.

```
services:
  (생략)
  nginx:
    image: nginx:1
    ports:
      - 80:80
    restart: always
```

restart: always 이런거 넣어두면 컨테이너가 꺼져도 알아서 재시작됩니다.

심지어 docker 엔진 자체가 껐다 켜져도 알아서 서비스가 자동으로 시작됩니다.

그래서 항상 재시작되어야하는 프로그램이 있으면 이거 적어둡시다.

참고로 docker compose 안쓸거면 docker run -d --restart always 이런 식으로 옵션을 집어넣습니다.

엄마가 남의 말 믿지 말랬으니 진짜인지 확인하려면 docker desktop 껐다 켜보셔도 되고

아니면 컨테이너를 오류발생시켜서 끄고 싶으면 nginx같은거에 docker exec으로 접속해서 kill 명령한번 줘보면 됩니다.

![](https://d2hxk0kgvzehcg.cloudfront.net/wp-content/uploads/2024/11/%EC%A0%9C%EB%AA%A9-%EC%97%86%EC%9D%8C3.png)

▲ 터미널에 ps 입력하면 현재 실행중인 프로세스들을 볼 수 있는데

잘보면 1번 프로세스로 nginx 명령어가 실행중입니다.

이걸 강제종료 해버리고 싶으면 터미널에 kill 1 입력하면 됩니다.

근데 restart always를 적어놨기 때문에 종료되어도 얘가 알아서 재시작되는걸 볼 수 있습니다.

(재시작 되었는지 모르겠으면 컨테이너의 Inspect 메뉴에서 restart 어쩌구 검색해봅시다.)

참고로 여러분들이 docker 명령어나 이런걸로 **컨테이너를 직접 정지시켰을 때는**

restart를 뭘로 해놨든 간에 자동 재시작은 안됩니다.

```
services:
  (생략)
  nginx:
    image: nginx:1
    ports:
      - 80:80
    restart: unless-stopped
```

restart: unless-stopped 이런 명령도 비슷한데 얘는 docker 재시작해도 자동으로 시작은 안됩니다.

실은 비슷해서 그냥 이거 쓰도록 합시다.

---
