services:
  webserver:
    image: nodeserver:v1
    build: .
    ports:
      - "8080:8080"

    develop:
      watch:
        - action: sync+restart # 소스코드 변경 시 컨테이너 재시작
          path: . # path: 에는 내 컴퓨터의 어떤 파일들 감시할건지 경로 적으면 됩니다.
          target: /app # target: 에는 컨테이너 내부의 어느 경로에 동기화할건지 적으면 됩니다.
          ignore: # 감시 제외할 경로들
            - node_modules/
        - action: rebuild # 소스코드 변경 시 이미지 재빌드 후 컨테이너 재시작
          path: package.json
    # depends_on: 이 서비스가 시작되기 전에 먼저 시작되어야 할 서비스 지정
    # db가 먼저 시작된 후 webserver가 시작됨 (단, db가 완전히 준비될 때까지 기다리지는 않음)
    depends_on:
      - "db"
    networks:
      - mynet1 # nginx와 통신 가능
      - mynet2 # db와 통신 가능
    # 추천: restart 정책 추가
    restart: unless-stopped

  nginx:
    image: nginx:v1
    ports:
      - "80:80"
    # volumes: Bind Mount 방식 사용
    # 호스트의 ./nginx/myconfig1.conf 파일을 컨테이너 내부로 직접 마운트
    # 파일 수정 시 컨테이너 재시작만으로 반영 가능 (이미지 재빌드 불필요)
    volumes:
      - ./nginx/myconfig1.conf:/etc/nginx/conf.d/myconfig1.conf
    depends_on:
      - webserver
    networks:
      - mynet1
    # restart: always - 오류 발생 시, Docker 재시작 시 모두 자동 실행
    restart: always
    # 추천: unless-stopped로 변경 (더 안전함)
    # restart: unless-stopped

  db:
    image: postgres:18.0-alpine
    environment:
      # ${POSTGRES_USER}: .env 파일에서 환경변수를 읽어옴
      # .env 파일에 POSTGRES_USER=admin 형태로 저장되어 있어야 함
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      # "5431:5432" - 호스트의 5431 포트를 컨테이너의 5432 포트에 연결
      # (기본 5432를 피하기 위해 5431 사용 - 좋은 선택!)
      - "5431:5432"
    networks:
      - mynet2
    volumes:
      # Named Volume 방식 사용
      # Docker가 관리하는 test 볼륨을 DB 데이터 디렉토리에 마운트
      - test:/var/lib/postgresql/data
    # 추천: restart 정책 추가
    restart: unless-stopped

networks:
  mynet1: # nginx-webserver 간 통신용 네트워크
  mynet2: # webserver-db 간 통신용 네트워크

volumes:
  test:
    # external: true - 이미 생성된 test_vol 볼륨을 사용
    # 사전에 'docker volume create test_vol' 명령으로 볼륨 생성 필요
    external: true
